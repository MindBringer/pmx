{
  "name": "Agent Orchestrator V2",
  "nodes": [
    {
      "parameters": {
        "jsCode": "// Prepare Persona Items — persona-only board, focus/questions in Prompt, robust provider/model mapping\n\n// --------------- helpers ---------------\nconst norm = v => String(v ?? '').trim();\nconst isArr = a => Array.isArray(a);\n\n// zugelassene Provider\nconst ALLOWED = new Set(['groq','openai','anthropic','mistralapi','openrouter','huggingface','mistral','vllm']);\n\n// Provider aus Modellnamen raten (vLLM bevorzugen)\nfunction guessProviderFromModel(m) {\n  const s = norm(m).toLowerCase();\n  if (!s) return '';\n  if (s.includes('claude')) return 'anthropic';\n  if (s.startsWith('o1') || s.startsWith('o3') || s.startsWith('gpt-')) return 'openai';\n  if (s.startsWith('openrouter/') || s.includes('openrouter:')) return 'openrouter';\n  if (s.startsWith('openai/')) return 'openrouter';\n  if (s.includes('mistral') || s.includes('mixtral')) return 'mistral';\n  // typische HF/vLLM Modelle → vllm\n  if (s.includes('qwen') || s.includes('phi') || s.includes('llama') ||\n      s.includes('gemma') || s.includes('deepseek') || s.includes('yi') ||\n      s.includes('falcon') || s.includes('vicuna') || s.includes('wizard')) return 'vllm';\n  if (s.includes('/')) return 'vllm';\n  return '';\n}\n\n// Provider/Model → Router-Felder (Default: vllm)\nfunction mapProviderModel(providerIn, modelIn) {\n  let prov = norm(providerIn).toLowerCase();\n  let mdl  = norm(modelIn); // Modellnamen NICHT lowercasen!\n\n  if (!ALLOWED.has(prov)) {\n    const guessedFromProv = guessProviderFromModel(prov);\n    if (guessedFromProv) { mdl = prov; prov = guessedFromProv; }\n  }\n  if (!ALLOWED.has(prov)) {\n    const guessedFromMdl = guessProviderFromModel(mdl);\n    if (guessedFromMdl) prov = guessedFromMdl;\n  }\n\n  if (!ALLOWED.has(prov)) prov = 'vllm'; // ← gewünschter Default\n\n  if (!mdl) {\n    if (prov === 'groq')            mdl = 'llama-3.1-70b-versatile';\n    else if (prov === 'openai')     mdl = 'gpt-4o-mini';\n    else if (prov === 'anthropic')  mdl = 'claude-3-5-sonnet';\n    else if (prov === 'mistralapi') mdl = 'mistral-large-latest';\n    else if (prov === 'openrouter') mdl = 'openai/gpt-oss-120b';\n    else if (prov === 'huggingface')mdl = 'meta-llama/Meta-Llama-3-8B-Instruct';\n    else if (prov === 'mistral')    mdl = 'llama3';\n    else /* vllm */                 mdl = 'Qwen/Qwen2.5-7B-Instruct-GPTQ-Int4';\n  }\n\n  switch (prov) {\n    case 'groq':        return { model: 'groq',        groq_model: mdl };\n    case 'openai':      return { model: 'openai',      openai_model: mdl };\n    case 'anthropic':   return { model: 'anthropic',   claude_model: mdl };\n    case 'mistralapi':  return { model: 'mistralapi',  mistral_model: mdl };\n    case 'openrouter':  return { model: 'openrouter',  openrouter_model: mdl };\n    case 'huggingface': return { model: 'huggingface', hf_model: mdl };\n    case 'mistral':     return { model: 'mistral',     ollama_model: mdl };\n    case 'vllm':\n    default:            return { model: 'vllm',        vllm_model: mdl };\n  }\n}\n\n// --------------- input normalize ---------------\nconst root  = ($json && typeof $json === 'object') ? $json : {};\nlet pre = root;\n\nif (!root.personas && !root.body?.personas) {\n  try {\n    const it = $items(\"Agents Preflight (Normalize)\", 0)[0];\n    if (it && it.json) pre = it.json;\n  } catch {}\n}\n\nconst personas =\n  isArr(root.personas) ? root.personas :\n  isArr(pre.personas)  ? pre.personas  :\n  isArr(root.body?.personas) ? root.body.personas : [];\n\nconst state     = root.state || {};\nconst task      = norm(root.prompt ?? pre.prompt ?? root.body?.prompt ?? state.task);\nconst globalSys = norm(root.system ?? pre.system ?? root.body?.system);\nconst rag       = !!(root.rag ?? pre.rag ?? root.body?.rag);\nconst rag_tags_ = root.rag_tags ?? pre.rag_tags ?? root.body?.rag_tags;\nconst rag_tags  = Array.isArray(rag_tags_) ? rag_tags_ : [];\nconst convId    = root.conversation_id ?? pre.conversation_id ?? null;\nconst jobId     = root.job_id ?? pre.job_id ?? root.body?.job_id ?? root.jobId ?? pre.jobId ?? null;\nconst memory    = root.memory ?? pre.memory ?? null;\n\nconst round         = Number(state.round ?? root.round ?? 1);\nconst agent_rounds  = Number(state.rounds_total ?? state.agent_rounds ?? root.agent_rounds ?? pre.agent_rounds ?? 1);\nconst boardPersonaText = norm(state.boardPersonaText || root.boardPersonaText || root.boardText);\nconst focus     = Array.isArray(state.critic_focus) ? state.critic_focus : [];\nconst questions = Array.isArray(state.critic_questions) ? state.critic_questions : [];\n\nconst focusLines = (focus.length ? [`- Beantworte diese Fokusaufgaben:`, ...focus.map(s => `  - ${norm(s)}`)] : []);\nconst questionLines = (questions.length ? [`- Beantworte diese Fragen:`, ...questions.map(s => `  - ${norm(s)}`)] : []);\n\n// --------------- build per-persona items ---------------\nconst personaItems = Array.isArray(personas) ? personas.map((p, idx) => {\n  const label = norm(p.label || `Persona ${idx+1}`);\n  const mapped = mapProviderModel(p.provider, p.model);\n  const roleSystem = [globalSys, `Rolle: ${label}.`].filter(Boolean).join('\\n\\n');\n  const personaPrompt = [\n    `Teamaufgabe: ${task}`,\n    `Dein Beitrag (Rolle: \"${label}\") in Runde ${round} von ${agent_rounds}:`,\n    `- Liefere einen fokussierten, in sich verständlichen Abschnitt (max. 12 Sätze).`,\n    `- Beziehe dich auf die bisherigen Team-Ergebnisse (nur Persona-Inhalte).`,\n    ...focusLines,\n    ...questionLines,\n    boardPersonaText ? `\\nBisherige Team-Ergebnisse (Persona-Inhalte):\\n${boardPersonaText}` : ''\n  ].filter(Boolean).join('\\n');\n\n  return {\n    json: {\n      ...mapped,\n      label,\n      prompt: personaPrompt,\n      system: roleSystem,\n      rag, rag_tags,\n      conversation_id: convId,\n      memory,\n      round,\n      agent_rounds,\n      board: Array.isArray(root.board) ? root.board : [],\n      boardText: boardPersonaText,\n      job_id: jobId\n    }\n  };\n}) : [];\n\n// --------------- return (modus-sicher) ---------------\nconst isAllItemsMode = (typeof items !== 'undefined');\n\nif (!Array.isArray(personas) || personas.length === 0) {\n  const one = { json: { error: \"No personas provided\", info: \"Prepare Persona Items erwartet personas[]\" } };\n  return isAllItemsMode ? [one] : one;\n}\n\nreturn isAllItemsMode\n  ? personaItems                 // Run once for all items → Array von Items\n  : { json: { personas: personaItems.map(i => i.json) } }; // Each-item-Modus: ein Objekt (ohne Fan-out)\n"
      },
      "id": "2db3ee54-af1c-4092-883a-6cb97dd975c9",
      "name": "Prepare Persona Items",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2240,
        64
      ]
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "b40VJ560cdjZeCOR",
          "mode": "list",
          "cachedResultName": "RAG Router V3"
        },
        "workflowInputs": {
          "mappingMode": "passThrough",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "mode": "each",
        "options": {}
      },
      "id": "d4683843-a00b-4471-8c7c-f39164f5ec75",
      "name": "Run RAG_Router (Agents)",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        -1568,
        192
      ]
    },
    {
      "parameters": {
        "jsCode": "// Collect Agent Outputs — persona-only, strip <think>, collect thinkPersona[]\n// Quelle für Rundeninfos aus \"Prepare Persona Items\"\nconst preItems  = $items('Prepare Persona Items', 0);\nconst baseState = preItems?.[0]?.json ?? {};\nconst prevState = $json || {};\nconst state     = { ...baseState, ...prevState };\n\nconst agentResults = $input.all();\n\n// Collect Agent Outputs — persona-only, robust think-extraction\nfunction extractThinkAndClean(s) {\n  const src = String(s || '');\n  const thinks = [];\n\n  // 1) <think>...</think>\n  let clean = src.replace(/<think>([\\s\\S]*?)<\\/think>\\s*/gi, (_, t) => {\n    const seg = String(t || '').trim(); if (seg) thinks.push(seg); return '';\n  });\n\n  // 2) ```think ... ```\n  clean = clean.replace(/```(?:think|thinking|reasoning)[\\t ]*\\n([\\s\\S]*?)```/gi, (_, t) => {\n    const seg = String(t || '').trim(); if (seg) thinks.push(seg); return '';\n  });\n\n  // 3) Markdown-Heading \"### Think ... (bis zum nächsten Heading oder Ende)\"\n  clean = clean.replace(/(^|\\n)#{2,3}\\s*think\\b[\\s\\S]*?(?=(\\n#{2,3}\\s)|$)/gi, (m) => {\n    const seg = m.replace(/^.*?\\n/, '').trim(); if (seg) thinks.push(seg); return '';\n  });\n\n  // 4) \"THINK:\" Block (bis zur nächsten Leerzeile / Heading / Ende)\n  clean = clean.replace(/(^|\\n)think:\\s*([\\s\\S]*?)(?=\\n\\s*\\n|\\n#{1,6}\\s|$)/gi, (_, __, t) => {\n    const seg = String(t || '').trim(); if (seg) thinks.push(seg); return '';\n  });\n\n  return { clean: clean.trim(), thinks };\n}\n\nconst board = agentResults.map(it => {\n  const j   = it.json || {};\n  const raw = (j.text || j.result || '').trim();\n  if (!raw) return null;\n  const { clean, thinks } = extractThinkAndClean(raw);\n  const label    = j.label || j.persona?.label || 'Agent';\n  const provider = j.provider || j.model || j.model_used || '';\n  return { label, text: clean, provider, thinks };\n}).filter(Boolean);\n\nconst boardPersonaText = board.map(b => `### ${b.label}\\n${b.text}`).join('\\n\\n');\n\nconst thinkPersona = Array.isArray(state.thinkPersona) ? state.thinkPersona.slice() : [];\nboard.forEach(b => {\n  if (b.thinks && b.thinks.length) {\n    thinkPersona.push({\n      round: Number(state.round || 1),\n      label: b.label,\n      raw: b.thinks\n    });\n  }\n});\n\nreturn [{\n  json: {\n    ...state,\n    board: board.map(({ thinks, ...rest }) => rest),\n    boardText: boardPersonaText,     // rückwärts-kompatibel\n    boardPersonaText,                // Writer-Material\n    thinkPersona\n  }\n}];\n"
      },
      "id": "c6a3c593-298d-419f-aa8e-ddd328ede893",
      "name": "Collect Agent Outputs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -672,
        64
      ]
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "b40VJ560cdjZeCOR",
          "mode": "list",
          "cachedResultName": "RAG Router V3"
        },
        "workflowInputs": {
          "mappingMode": "passThrough",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "id": "390a6777-28d7-4594-b06e-3fe6ca22a790",
      "name": "Run RAG_Router (Writer)",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        3584,
        336
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Format Agent Response — writer-only final text, JSON/Focus/Questions herausziehen, think-strip, Moderator-Notes anhängen\n\nfunction pickStr(...cands){ for (const v of cands) if (typeof v === 'string' && v.trim()) return v.trim(); return ''; }\nfunction get(o, p){ return p.split('.').reduce((a,k)=>(a && a[k] !== undefined ? a[k] : undefined), o); }\nfunction stripThink(s){ return String(s || '').replace(/<think>[\\s\\S]*?<\\/think>\\s*/gi, '').trim(); }\n\n// --- NEW: JSON/Sections erkennen -> in Notes verschieben\nfunction formatNotes(obj){\n  const parts = [];\n  if (obj.summary) parts.push(`### Zusammenfassung (Moderator)\\n${String(obj.summary).trim()}`);\n  if (Array.isArray(obj.focus) && obj.focus.length) parts.push(`### Fokus für die nächste Runde\\n${obj.focus.map(s=>`- ${String(s).trim()}`).join('\\n')}`);\n  if (Array.isArray(obj.questions) && obj.questions.length) parts.push(`### Fragen für die nächste Runde\\n${obj.questions.map(s=>`- ${String(s).trim()}`).join('\\n')}`);\n  return parts.join('\\n\\n');\n}\nfunction tryParseJson(s){\n  try { return JSON.parse(s); } catch { return null; }\n}\nfunction extractEmbeddedModeratorFromText(txt){\n  let out = String(txt || '');\n  let collected = [];\n\n  // 1) ```json ... ```\n  out = out.replace(/```json\\s*([\\s\\S]*?)```/gi, (_, body)=>{\n    const parsed = tryParseJson(String(body||'').trim());\n    if (parsed && (parsed.summary || parsed.focus || parsed.questions)) {\n      const note = formatNotes(parsed);\n      if (note) collected.push(note);\n      return '';\n    }\n    return '';\n  });\n\n  // 2) reines JSON-Objekt als ganzer Text\n  const trimmed = out.trim();\n  if (trimmed.startsWith('{') && trimmed.endsWith('}')) {\n    const parsed = tryParseJson(trimmed);\n    if (parsed && (parsed.summary || parsed.focus || parsed.questions)) {\n      const note = formatNotes(parsed);\n      if (note) collected.push(note);\n      out = '';\n    }\n  }\n\n  // 3) Überschriften/Abschnitte \"Fokus/Fragen\" im Text (LLM-Eigenleistung) entfernen → Notes sammeln\n  function harvestSection(name){\n    // Bis nächste Überschrift (### ...) oder Ende\n    const re = new RegExp(`(^|\\\\n)###\\\\s*${name}\\\\b[\\\\s\\\\S]*?(?=(\\\\n###\\\\s)|$)`, 'gi');\n    out = out.replace(re, (m)=>{\n      const body = m.replace(/^.*?\\n/, '').trim();\n      if (body) {\n        const lines = body.split(/\\r?\\n/).map(s=>s.replace(/^\\s*[-*]\\s?/, '').trim()).filter(Boolean);\n        const obj = (name.toLowerCase().startsWith('fokus')||name.toLowerCase().startsWith('focus'))\n          ? { focus: lines } : { questions: lines };\n        const note = formatNotes(obj);\n        if (note) collected.push(note);\n      }\n      return '';\n    });\n  }\n  harvestSection('Fokus');\n  harvestSection('Focus');\n  harvestSection('Fragen');\n  harvestSection('Questions');\n\n  return { text: out.trim(), notes: collected.filter(Boolean).join('\\n\\n') };\n}\nfunction unwrapWholeTextBrackets(s){\n  // Entfernt nur EIN Paar rund/ eckig, wenn es den GESAMTEN Text umschließt.\n  const t = String(s||'').trim();\n  const m1 = t.match(/^\\(\\s*([\\s\\S]*?)\\s*\\)$/);\n  if (m1) return m1[1].trim();\n  const m2 = t.match(/^\\[\\s*([\\s\\S]*?)\\s*\\]$/);\n  if (m2) return m2[1].trim();\n  return t;\n}\nfunction sanitizeAnswer(s){\n  let out = stripThink(s);\n  // JSON & Sections herausziehen (hier nur der Text; Notes sammeln wir separat)\n  const ex = extractEmbeddedModeratorFromText(out);\n  out = ex.text;\n  // führende/backende Klammern, wenn sie *alles* umschließen\n  out = unwrapWholeTextBrackets(out);\n  // übrig gebliebene ```json```/```...``` Fences ohne Inhalt entsorgen\n  out = out.replace(/```[\\s\\S]*?```/g, '').trim();\n  return { text: out, embeddedNotes: ex.notes };\n}\n\n// --------- Bestehende Flatten-Logik (gekürzt aus deiner Version) ---------\nfunction tryParse(x){ if (typeof x === 'string') { try { return JSON.parse(x); } catch {} } return x; }\nfunction flattenToPayload(data){\n  let cur = data, hops = 0;\n  while (cur && typeof cur === 'object' && !Array.isArray(cur) && cur.result !== undefined && hops < 6){\n    cur.result = tryParse(cur.result);\n    const r = cur.result || {};\n    if (typeof r.answer === 'string' || typeof r.text === 'string' || Array.isArray(r.sources) || r.artifacts) break;\n    cur = r; hops++;\n  }\n  return (cur && typeof cur.result === 'object') ? cur.result : cur;\n}\n\nconst cur         = item.json ?? {};\nconst writerItems = $items('Run RAG_Router (Writer)', 0) || [];\nconst writerRaw   = writerItems[0]?.json || {};\nconst critic      = $items('Apply Critic Feedback', 0)?.[0]?.json ?? {};\n\nconst flatWriter  = flattenToPayload(writerRaw);\nconst flatCur     = flattenToPayload(cur);\n\n// 1) Writer bevorzugt, dann aktuelles Item (KEIN Critic-Fallback)\nconst writerAnswer = pickStr(\n  flatWriter?.answer, flatWriter?.text,\n  get(writerRaw,'result.answer'), get(writerRaw,'result.text'),\n  get(writerRaw,'choices.0.message.content'), get(writerRaw,'choices.0.text'),\n  get(writerRaw,'data.choices.0.message.content')\n);\nconst curAnswer = pickStr(\n  flatCur?.answer, flatCur?.text,\n  get(cur,'result.answer'), get(cur,'result.text'),\n  get(cur,'choices.0.message.content'), get(cur,'choices.0.text'),\n  get(cur,'data.choices.0.message.content')\n);\n\nconst rawText = writerAnswer || curAnswer || '';\nconst { text: cleanText, embeddedNotes } = sanitizeAnswer(rawText);\n\n// 2) Quellen & Artefakte mergen (Writer bevorzugt)\nconst sources =\n  (Array.isArray(cur.sources) && cur.sources) ||\n  (Array.isArray(flatCur?.sources) && flatCur.sources) ||\n  (Array.isArray(writerRaw.sources) && writerRaw.sources) ||\n  (Array.isArray(flatWriter?.sources) && flatWriter.sources) || [];\n\nconst artifacts = {\n  ...(flatCur?.artifacts || {}),\n  ...(cur.artifacts || {}),\n  ...(flatWriter?.artifacts || {}),\n  ...(writerRaw.artifacts || {}),\n};\n\n// 3) Moderator-Notizen aus State + ggf. eingebettete Notes hinzufügen\nconst state = cur.state || writerRaw.state || critic.state || {};\nconst moderatorNotes = String(state.boardModeratorNotes || '').trim();\nconst notesMerged = [ moderatorNotes, embeddedNotes ].filter(Boolean).join('\\n\\n');\nif (notesMerged) artifacts.moderator_notes = notesMerged;\n\n// 4) Setzen — boardText NICHT überschreiben (bleibt Persona-only)\ncur.answer    = cleanText;\ncur.sources   = cur.sources ?? sources;\ncur.artifacts = artifacts;\n\nitem.json = cur;\nreturn item;\n"
      },
      "id": "8253ca25-313a-4e05-bf05-83569d5ab44b",
      "name": "Format Agent Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4032,
        192
      ]
    },
    {
      "parameters": {
        "jsCode": "// Agents Preflight (Normalize) — SINGLE item with personas[]\nconst base = ($json && typeof $json === 'object') ? $json : {};\n\nlet personas = base.personas ?? base.body?.personas ?? [];\nif (typeof personas === 'string') {\n  try { personas = JSON.parse(personas); }\n  catch {\n    personas = personas.split(/\\r?\\n|;|\\|/).map(s => ({ label: s.trim() })).filter(p => p.label);\n  }\n}\nif (!Array.isArray(personas) || personas.length === 0) {\n  personas = [{\n    label: base.persona_label || base.label || 'Agent',\n    provider: base.persona_provider || base.provider || base.model || 'groq',\n    model: base.persona_model || base.openai_model || base.groq_model || base.ollama_model || base.mistral_model || base.hf_model || base.model || 'llama3',\n    system: base.persona_system || base.system || '',\n    prompt: base.persona_prompt || ''\n  }];\n}\n\n// optional: Mapping beibehalten, aber NICHT mehr pro Item ausgeben\nfunction mapProvider(prov, model){\n  const p = String(prov || '').toLowerCase();\n  if (p === 'groq')        return { model: 'groq',       groq_model: model };\n  if (p === 'openai')      return { model: 'openai',     openai_model: model };\n  if (p === 'anthropic')   return { model: 'anthropic',  claude_model: model };\n  if (p === 'mistralapi')  return { model: 'mistralapi', mistral_model: model };\n  if (p === 'openrouter')  return { model: 'openrouter', openrouter_model: model || 'openai/gpt-oss-120b' };\n  if (p === 'huggingface') return { model: 'huggingface', hf_model: model };\n  return { model: 'vllm' };\n}\n\npersonas = personas.map((p, i) => {\n  const prov = p.provider || base.provider || 'groq';\n  const mdl  = p.model || base.model || 'llama3';\n  const mapped = mapProvider(prov, mdl);\n  return { ...p, label: p.label || `Agent ${i+1}`, provider: prov, model: mdl, ...mapped };\n});\n\n// EIN Item mit personas[]\nreturn [{ json: { ...base, personas } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2688,
        144
      ],
      "id": "0ea4de9c-8b43-48b8-82d0-c5980b3c2fc2",
      "name": "Agents Preflight (Normalize)"
    },
    {
      "parameters": {
        "jsCode": "// Build Writer Prompt — CLEAN VERSION (Writer-only)\n// - entfernt Persona-Direktiven (Dein Beitrag/Runde/Erwarte JSON/...)\n// - nimmt NUR Persona-Inhalte für den Writer\n// - Writer-System ist separat (kein Critic/Facilitator)\n\nconst j = ($json && typeof $json === 'object') ? $json : {};\nconst norm = v => (v == null ? '' : String(v)).trim();\nconst isArr = Array.isArray;\n\nconst stripFences = s => norm(s).replace(/^```[a-zA-Z]*\\n?|\\n?```$/g, '');\nconst stripThink  = s => stripFences(s).replace(/<think>[\\s\\S]*?<\\/think>\\s*/g, '').trim();\nconst stripPersonaDirectives = s => stripFences(s)\n  .replace(/^.*?Dein Beitrag.*$/gmi, '')\n  .replace(/^.*?Erwarte JSON.*$/gmi, '')\n  .replace(/^Runde\\s+\\d+\\s+von\\s+\\d+.*$/gmi, '')\n  .replace(/^Bisherige Team-Ergebnisse.*$/gmi, '')\n  .replace(/^Team-Ergebnisse.*$/gmi, '')\n  .replace(/^\\s*Stop\\s*=\\s*(true|false)\\s*$/gmi, '')\n  .trim();\n\n// ---- State/IDs ----\nconst state = j.state || {};\nconst jobId =\n  j.job_id || j.jobId || state.job_id ||\n  j.__event_base?.job_id || j.__event?.job_id || j.body?.job_id || null;\n\n// ---- Ursprungsfrage (ohne Persona-Direktiven) ----\nconst basePromptRaw =\n  j.base_prompt || state.base_prompt || state.user_prompt ||\n  j.user_prompt || j.input?.prompt || j.body?.prompt || j.prompt || '';\nconst basePrompt = stripPersonaDirectives(basePromptRaw);\n\n// ---- Persona-only Material ----\nconst personaOnly =\n  stripThink(j.boardPersonaText) ||\n  (isArr(j.board)\n    ? stripThink(j.board.map(b => `${b.label ? `### ${b.label}\\n` : ''}${norm(b.text)}`).join('\\n\\n'))\n    : ''\n  );\n\n// ---- Writer-System (KEIN Critic/Facilitator hier!) ----\nconst writerSystem = [\n  'Du bist der **Writer/Redakteur** eines Agententeams.',\n  'Nutze ausschließlich die Persona-Inhalte (keine Moderator/Critic/Tool-Texte, keine internen Denkabschnitte).',\n  'Liefere eine klare Abschlussfassung:',\n  '1) Kurzfassung (max. 5 Sätze)',\n  '2) Details je Bereich',\n  '3) Entscheidungen',\n  '4) Offene Punkte / Risiken',\n  'Schreibe nüchtern, präzise, konsistent.'\n].join('\\n');\n\n// ---- Writer-Prompt ----\nconst writerPrompt = [\n  `Teamaufgabe: ${basePrompt || '(ohne Titel)'}`,\n  '',\n  'Team-Ergebnisse (nur Persona-Inhalte):',\n  personaOnly || '(keine Persona-Inhalte verfügbar)'\n].join('\\n');\n\n// ---- Provider/Model Mapping ----\nconst allowed = new Set(['groq','openai','anthropic','mistralapi','openrouter','huggingface','mistral','vllm']);\nconst provIn  = norm(j.writer?.provider || j.model || j.provider).toLowerCase();\nconst provider = allowed.has(provIn) ? provIn : 'vllm';\nlet modelFields = {};\nswitch (provider) {\n  case 'groq':       modelFields = { model:'groq',       groq_model: j.groq_model || j.writer?.model || 'llama-3.1-70b-versatile' }; break;\n  case 'openai':     modelFields = { model:'openai',     openai_model: j.openai_model || j.writer?.model || 'gpt-4o-mini'           }; break;\n  case 'anthropic':  modelFields = { model:'anthropic',  claude_model: j.claude_model || j.writer?.model || 'claude-3-5-sonnet'     }; break;\n  case 'mistralapi': modelFields = { model:'mistralapi', mistral_model: j.mistral_model || j.writer?.model || 'mistral-large-latest'}; break;\n  case 'openrouter': modelFields = { model:'openrouter', openrouter_model: j.openrouter_model || j.writer?.model || 'openai/gpt-oss-120b' }; break;\n  case 'huggingface':modelFields = { model:'huggingface',hf_model: j.hf_model || j.writer?.model || 'meta-llama/Meta-Llama-3-8B-Instruct'}; break;\n  case 'mistral':    modelFields = { model:'mistral',    ollama_model: j.ollama_model || j.writer?.model || 'llama3'                }; break;\n  case 'vllm':\n  default:           modelFields = { model:'vllm' };\n}\n\n// ---- Runden/Events für Logging ----\nconst round        = Number(state.round ?? j.round ?? 1);\nconst rounds_total = Number(state.rounds_total ?? state.agent_rounds ?? j.agent_rounds ?? 1);\nconst eventBase = { job_id: jobId, persona: 'Writer', role: 'writer', round, rounds_total };\n\n// ---- Finaler Payload nur für den Writer ----\nconst promoted = {\n  ...modelFields,\n  label: 'writer',\n  prompt: writerPrompt,\n  system: writerSystem,\n  rag: !!j.rag,\n  rag_tags: Array.isArray(j.rag_tags) ? j.rag_tags : [],\n  conversation_id: j.conversation_id ?? null,\n  memory: j.memory ?? null,\n  job_id: jobId,\n  __event_base: eventBase\n};\n\nconst writer_call = { ...promoted };\n\nreturn { json: { ...j, ...promoted, writer_call } };\n"
      },
      "id": "d14f27a5-3e80-4d74-8cc2-9c2e7b0b81cf",
      "name": "Build Writer Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2688,
        192
      ]
    },
    {
      "parameters": {
        "jsCode": "// Init Round State\nconst j = $json || {};\nconst rounds = Number(j.agent_rounds ?? j.body?.agent_rounds ?? 1);\nreturn [{\n  json: {\n    ...j,\n    round: 1,\n    agent_rounds: Math.max(1, rounds),\n    board: Array.isArray(j.board) ? j.board : [],\n    boardText: String(j.boardText || ''),\n  }\n}];"
      },
      "id": "abf7f178-3bd8-4393-a84d-1ae66aa41ffc",
      "name": "Init Round State",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1792,
        480
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare Critic/Facilitator Prompt — keine Resets von round/agent_rounds\nconst j = $json || {};\n\n// Provider-Mapping (separat steuerbar über j.critic)\nconst allowed = new Set(['groq','openai','anthropic','mistralapi','openrouter','huggingface','mistral','vllm']);\nconst provIn  = String(j.critic?.provider || j.model || j.provider || '').toLowerCase();\nconst provider = allowed.has(provIn) ? provIn : 'vllm';\nconst mdlIn   = String(j.critic?.model || '').toLowerCase();\n\nlet mapped = {};\nswitch (provider) {\n  case 'groq':       mapped = { model: 'groq',       groq_model: mdlIn || j.groq_model || 'llama-3.1-70b-versatile' }; break;\n  case 'openai':     mapped = { model: 'openai',     openai_model: mdlIn || j.openai_model || 'gpt-4o-mini' }; break;\n  case 'anthropic':  mapped = { model: 'anthropic',  claude_model: mdlIn || j.claude_model || 'claude-3-5-sonnet' }; break;\n  case 'mistralapi': mapped = { model: 'mistralapi', mistral_model: mdlIn || j.mistral_model || 'mistral-large-latest' }; break;\n  case 'vllm':\n  modelFields = { model:'vllm', persona:'critic' };\n  break;\n  case 'openrouter': mapped = { model: 'openrouter', openrouter_model: mdlIn || j.openrouter_model || 'openai/gpt-oss-120b' }; break;\n  case 'huggingface':mapped = { model: 'huggingface',hf_model: mdlIn || j.hf_model || 'meta-llama/Meta-Llama-3-8B-Instruct' }; break;\n  default:           mapped = { model: 'mistral',    ollama_model: mdlIn || j.ollama_model || 'llama3' };\n}\n\n// State sicher beibehalten\nconst round = Number(j.round ?? 1);\nconst total = Number(j.agent_rounds ?? 1);\n\n// Base-Prompt des Users für Anzeige/Memory konservieren\nconst basePrompt = j._original_prompt ?? j.prompt ?? '';\n\n// Prompt für den Critic\nconst criticSystem = [\n  'Du bist der **Facilitator/Critic** einer Agentenbesprechung.',\n  'Aufgaben:',\n  '- Verdichte die bisherigen Team-Ergebnisse,',\n  '- markiere Widersprüche/Lücken.',\n  '- Stelle 1–3 präzise Fragen an den/die Agent:in (kurz, nummeriert).',\n  '- Formuliere max. 3 konkrete Fokusaufgaben für die nächste Runde,',\n  '- entscheide, ob eine weitere Runde nötig ist (stop=true/false).'\n].join('\\n');\n\nconst boardText = j.boardText || '';\nconst criticUser = [\n  `Aufgabe (User): ${basePrompt}`,\n  '',\n  `Runde ${round} von ${total}`,\n  '',\n  'Bisherige Team-Ergebnisse:',\n  boardText || '(noch keine)',\n  '',\n  'Erwarte JSON: { \"summary\": string, \"focus\": [string], \"questions\": [string], \"stop\": boolean }'\n].join('\\n');\n\nreturn {\n  json: {\n    ...j,\n    ...mapped,\n    // WICHTIG: State-Felder explizit mitgeben\n    round,\n    agent_rounds: total,\n    // Anzeige/Memory: _original_prompt setzen, prompt für den Critic setzen\n    _original_prompt: basePrompt,\n    prompt: criticUser,\n    system: criticSystem\n  }\n};\n"
      },
      "id": "3ef98bdc-1e9f-480c-921d-d39faebd7fb9",
      "name": "Prepare Critic Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        448,
        64
      ]
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "b40VJ560cdjZeCOR",
          "mode": "list",
          "cachedResultName": "RAG Router V3"
        },
        "workflowInputs": {
          "mappingMode": "passThrough",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "id": "d03e1b82-717e-4fc2-b51c-c369adcb13f6",
      "name": "Run RAG_Router (Critic)",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        1120,
        192
      ]
    },
    {
      "parameters": {
        "jsCode": "// Apply Critic Feedback — Moderator-Notizen + job_id passthrough\n\nfunction firstValidJson(items) {\n  for (const it of items) {\n    const v = it.json;\n    if (v && (v.summary || v.focus || v.questions || v.stop !== undefined)) return v;\n    try { const p = JSON.parse(String(v||'{}')); if (p && (p.summary || p.focus || p.questions || p.stop !== undefined)) return p; } catch {}\n  }\n  return {};\n}\n\nconst cur    = $json || {};\nconst state0 = cur.state || {};\n// job_id aus allen sinnvollen Quellen zusammensuchen (inkl. Critic-Run)\nconst job_id =\n  cur.job_id ??\n  state0.job_id ??\n  $items('Run RAG_Router (Critic)', 0)?.[0]?.json?.job_id ??\n  $items('Run RAG_Router (Critic)', 0)?.[0]?.json?.state?.job_id ??\n  cur.__event_base?.job_id ??\n  cur.body?.job_id ??\n  null;\n\nconst parsed = firstValidJson(items);\nconst summary   = String(parsed.summary || '').trim();\nconst focus     = Array.isArray(parsed.focus)     ? parsed.focus.map(s=>String(s).trim()).filter(Boolean) : [];\nconst questions = Array.isArray(parsed.questions) ? parsed.questions.map(s=>String(s).trim()).filter(Boolean) : [];\nconst stop      = Boolean(parsed.stop);\n\nconst blocks = [];\nif (summary)          blocks.push(`### Zusammenfassung (Moderator)\\n${summary}`);\nif (focus.length)     blocks.push(`### Fokus für die nächste Runde\\n${focus.map(s=>`- ${s}`).join('\\n')}`);\nif (questions.length) blocks.push(`### Fragen für die nächste Runde\\n${questions.map(s=>`- ${s}`).join('\\n')}`);\n\nconst boardModeratorNotes = [state0.boardModeratorNotes || '', blocks.join('\\n\\n')].filter(Boolean).join('\\n\\n');\n\nconst state = {\n  ...state0,\n  job_id,                       // <<— wichtig\n  critic_summary: summary || undefined,\n  critic_focus: focus,\n  critic_questions: questions,\n  boardModeratorNotes,\n  stop\n};\n\nreturn [{ json: { ...cur, job_id, state } }];\n"
      },
      "id": "273682ae-07b3-4e74-b5a2-99760e362667",
      "name": "Apply Critic Feedback",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1568,
        64
      ]
    },
    {
      "parameters": {
        "jsCode": "// STATE MANAGER NODE – Zentraler Rundenzähler & Event-Basis (ohne Cross-Refs)\n// - Arbeitet ausschließlich mit $input.all()\n// - Keine $items(...) / $node[...] → keine versteckten Abhängigkeiten\n// - Liefert __event_base, damit Event-Nodes nur $json brauchen\n\nconst allItems = $input.all();\n\nfunction normStr(v) {\n  return (typeof v === 'string' ? v : (v == null ? '' : String(v)))\n    .replace(/^=+/, '') // z.B. \"=Barrista\" -> \"Barrista\"\n    .trim();\n}\nfunction pick(...vals) {\n  for (const v of vals) {\n    if (v === undefined || v === null) continue;\n    if (typeof v === 'string' && v.trim() === '') continue;\n    return v;\n  }\n  return undefined;\n}\nfunction pickFromItems(keys) {\n  for (const it of allItems) {\n    const j = it?.json || {};\n    for (const k of keys) {\n      const v = j[k];\n      if (v === undefined || v === null) continue;\n      if (typeof v === 'string' && v.trim() === '') continue;\n      return v;\n    }\n  }\n  return undefined;\n}\nfunction parseJobIdFromUrl(u) {\n  if (typeof u !== 'string') return undefined;\n  const m = u.match(/\\/rag\\/jobs\\/([0-9a-fA-F-]+)/);\n  return m?.[1];\n}\n\nconsole.log('=== STATE MANAGER ===');\nconsole.log(`Received ${allItems.length} items`);\n\nlet currentState = null;\nlet highestRound = 0;\nlet hasBoard = false;\n\n// besten State wählen\nfor (const it of allItems) {\n  const data = it.json || {};\n  const round = Number(data.round || 1);\n  const itemHasBoard = Array.isArray(data.board) && data.board.length > 0;\n  const itemHasCriticFeedback = Object.prototype.hasOwnProperty.call(data, 'stop');\n\n  if (\n    round > highestRound ||\n    (round === highestRound && itemHasBoard && !hasBoard) ||\n    (round === highestRound && itemHasCriticFeedback)\n  ) {\n    highestRound = round;\n    currentState = data;\n    hasBoard = itemHasBoard;\n  }\n}\n\nif (!currentState) {\n  currentState = { round: 1, agent_rounds: 2, board: [], boardText: '', stop: false };\n}\n\n// IDs & Basiswerte aus Items zusammensuchen (ohne Node-Refs)\nconst jobId = pick(\n  currentState.job_id,\n  pickFromItems(['job_id','jobId','id']),\n  parseJobIdFromUrl(pickFromItems(['events','result','complete']))\n) || null;\n\nconst convId = pick(currentState.conversation_id, pickFromItems(['conversation_id','conversationId'])) || null;\n\nconst persona = normStr(pick(currentState.persona, currentState.label, pickFromItems(['persona','label']), ''));\nconst role    = normStr(pick(currentState.role, pickFromItems(['role']), ''));\nconst round   = Number(pick(currentState.round, pickFromItems(['round'])) ?? 1);\nconst rounds  = Number(pick(currentState.agent_rounds, pickFromItems(['agent_rounds','rounds_total','roundsTotal'])) ?? 1);\n\nconst board   = Array.isArray(currentState.board) ? currentState.board : [];\nconst boardText = normStr(pick(currentState.boardText, currentState.answer, pickFromItems(['boardText','answer']), ''));\n\n// Standard-URLs (relativ, Nginx routet)\nconst eventsUrl   = pick(currentState.events,   jobId ? `/rag/jobs/${jobId}/events`   : '');\nconst resultUrl   = pick(currentState.result,   jobId ? `/rag/jobs/${jobId}/result`   : '');\nconst completeUrl = pick(currentState.complete, jobId ? `/rag/jobs/${jobId}/complete` : '');\n\nconst finalState = {\n  ...currentState,\n\n  // Kanonische Felder\n  round,\n  agent_rounds: rounds,\n  board,\n  boardText,\n  stop: Boolean(currentState.stop),\n\n  // IDs\n  job_id: jobId,\n  conversation_id: convId,\n\n  // Persona/Rolle\n  persona,\n  role,\n\n  // Endpunkte\n  events:   eventsUrl,\n  result:   resultUrl,\n  complete: completeUrl,\n\n  // Event-Basis (für Evt-Nodes/emit_event)\n  __event_base: {\n    job_id: jobId,\n    persona,\n    role,\n    round,\n    rounds_total: rounds\n  },\n\n  _state_manager: {\n    picked_from_items: allItems.length,\n    has_board: hasBoard,\n    ts: new Date().toISOString()\n  }\n};\n\n// EXAKT EIN ITEM zurück\nreturn [{ json: finalState }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2016,
        64
      ],
      "id": "40d8f0fd-433c-4208-946c-3c978731c815",
      "name": "State Manager"
    },
    {
      "parameters": {
        "jsCode": "const j = $json || {};\n\nconst round = Number(j.round || 1);\nconst maxRounds = Number(j.agent_rounds || 1);\nconst criticStop = Boolean(j.stop);\n\n// Einfache Abbruchlogik\nconst shouldContinue = !criticStop && round <= maxRounds;\n\n// Stop-Gründe sammeln\nconst stopReasons = [];\nif (criticStop) stopReasons.push(\"Critic Stop\");\nif (round > maxRounds) stopReasons.push(`Max Rounds (${round}>${maxRounds})`);\n\nconsole.log(`=== LOOP CHECKER ===`);\nconsole.log(`Round: ${round}/${maxRounds}`);\nconsole.log(`Critic Stop: ${criticStop}`);\nconsole.log(`Should Continue: ${shouldContinue}`);\nif (stopReasons.length > 0) {\n  console.log(`Stop Reasons: ${stopReasons.join(', ')}`);\n}\n\nreturn [{\n  json: {\n    ...j,\n    shouldContinue,\n    _loop_info: {\n      round,\n      maxRounds,\n      criticStop,\n      stopReasons: stopReasons.length > 0 ? stopReasons : null,\n      decision: shouldContinue ? 'CONTINUE' : 'STOP',\n      timestamp: new Date().toISOString()\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2240,
        64
      ],
      "id": "eb40a550-0899-4f38-a5f5-2d3d955062c2",
      "name": "Loop Checker"
    },
    {
      "parameters": {
        "jsCode": "// Round Incrementer — collapse to single state & bump round\nconst items = $input.all();\nconst base  = (items[items.length - 1]?.json) || ($json || {});\nconst currentMax = Math.max(...items.map(it => Number(it.json?.round ?? 1)), Number(base.round ?? 1));\nconst total = Number(base.agent_rounds ?? items[0]?.json?.agent_rounds ?? 1);\n\nreturn [{ json: { ...base, round: currentMax + 1, agent_rounds: total } }];\n"
      },
      "id": "cbe17307-e2d1-48e0-9556-ab4c1a990c1b",
      "name": "Round Incrementer",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1792,
        64
      ]
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -2464,
        144
      ],
      "id": "bf492d36-152d-4cf7-b0fd-310c41fe336a",
      "name": "Merge"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "761fd3b9-13a5-4825-b268-020062e0eac2",
              "leftValue": "={{ $json.shouldContinue === true }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2464,
        64
      ],
      "id": "1d8dc6b1-b77e-4f12-9957-508ee185bc18",
      "name": "Loop Gate"
    },
    {
      "parameters": {
        "jsCode": "// Parse Tool Calls from LLM text — robust, mehrere JSON-Objekte erlaubt\n// Erwartet in den Agenten-Antworten eingebettete Blöcke wie:\n// {\"tool\":\"web.search\",\"input\":{\"query\":\"...\", \"top_k\":3, \"recency_days\":30}}\n// {\"tool\":\"db.query\",\"input\":{\"kind\":\"postgres\",\"conn\":\"cred:pg_ro\",\"sql\":\"SELECT ... LIMIT 25\"}}\n\nconst MAX_CALLS = 3;\n\nfunction extractJsonObjects(s) {\n  const out = [];\n  const text = String(s || \"\");\n  // Simple JSON object finder (tolerant)\n  const regex = /\\{[\\s\\S]*?\\}/g;\n  let m;\n  while ((m = regex.exec(text)) !== null) {\n    try { out.push(JSON.parse(m[0])); } catch {}\n  }\n  return out;\n}\n\nconst items = $input.all();\nconst calls = [];\n\nfor (const it of items) {\n  const j = it.json || {};\n  const raw = j.text || j.result || j.response || \"\";\n  const found = extractJsonObjects(raw).filter(o => o && o.tool && o.input);\n  for (const f of found) calls.push(f);\n}\n\n// Limit & normalize\nconst allowed = calls.slice(0, MAX_CALLS).map((c, i) => ({\n  tool: String(c.tool).toLowerCase().trim(),\n  input: c.input || {},\n  _tool_idx: i + 1\n}));\n\nreturn [{\n  json: {\n    ...($json || {}),\n    tools: allowed,\n    _tools_info: { requested: calls.length, allowed: allowed.length, max: MAX_CALLS }\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -448,
        64
      ],
      "id": "caccbd4f-fc07-4d33-9cfb-54b502c9c1f7",
      "name": "Parse Tool Calls"
    },
    {
      "parameters": {
        "jsCode": "// Merge Tool Observations into State & BoardText\n\n// Aktueller State kommt bei dir aus vorherigen Nodes (z. B. Collect Agent Outputs / State Manager)\nconst state = ($items('Collect Agent Outputs', 0)?.[0]?.json) \n           || ($items('State Manager', 0)?.[0]?.json) \n           || ($json || {});\n\nconst toolsIn = ($json && Array.isArray($json.tool_observations)) ? $json.tool_observations : [];\n\nfunction fmtObs(o, idx) {\n  if (o.tool === 'web.search' && Array.isArray(o.items)) {\n    const lines = o.items.slice(0, 5).map((it,i)=>`- ${it.title || '(ohne Titel)'} — ${it.url || ''}\\n  ${it.snippet ? String(it.snippet).slice(0,240) : ''}`);\n    return `## Tool #${idx+1}: Websuche\\n${lines.join('\\n')}`;\n  }\n  if (o.tool === 'db.query') {\n    const rc = Number(o.rowCount || (o.rows?.length || 0));\n    const sample = Array.isArray(o.rows) ? o.rows.slice(0, 1)[0] : null;\n    return `## Tool #${idx+1}: DB-Query (${rc} Zeilen)\\n` + (sample ? \"Beispiel:\\n\" + JSON.stringify(sample, null, 2) : \"\");\n  }\n  if (o.tool === 'program.run') {\n    const out = String(o.stdout || '').slice(0, 1500);\n    const note = o.truncated ? '\\n[... gekürzt ...]' : '';\n    return `## Tool #${idx+1}: Programm-Ausgabe (Exit ${o.exitCode})\\n${out}${note}`;\n  }\n  return `## Tool #${idx+1}: ${o.tool}\\n${JSON.stringify(o).slice(0, 1000)}`;\n}\n\nconst toolsBlock = toolsIn.length ? `\\n\\n# Werkzeuge\\n${toolsIn.map(fmtObs).join('\\n\\n')}` : \"\";\n\nconst merged = {\n  ...state,\n  tool_observations: toolsIn,\n  boardToolText: [state.boardToolText || '', toolsBlock].filter(Boolean).join('\\n\\n')\n};\n\nreturn [{ json: merged }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        224,
        0
      ],
      "id": "f078b6c2-9fe7-4b09-a216-5cf924c8fdf5",
      "name": "Merge Tool Observations"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "IWAVpQy5PXkHrGWQ",
          "mode": "list",
          "cachedResultName": "Tools Router"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        0,
        0
      ],
      "id": "b4fcb8f7-a3e0-432a-8799-4ac160388c87",
      "name": "Run Tools Router"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "d5fa0809-dcbe-476c-85d1-b2c512453860",
              "leftValue": "={{ Array.isArray($json.tools) && $json.tools.length > 0 }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -224,
        64
      ],
      "id": "20a03dfd-8b5a-428e-bc19-181164e866fa",
      "name": "If"
    },
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -2912,
        208
      ],
      "id": "ad7598ea-db3a-4832-b454-3da2f33037fd",
      "name": "Execute Subflow"
    },
    {
      "parameters": {
        "jsCode": "// --- Helpers: robustes Extrahieren der finalen Antwort ---\nfunction isJobResultUrl(s){\n  if (typeof s !== 'string') return false;\n  try {\n    const u = new URL(s, 'http://dummy.local'); // base für relative Pfade\n    return /\\/rag\\/jobs\\/[^/]+\\/result$/.test(u.pathname);\n  } catch {\n    return /\\/rag\\/jobs\\/[^/]+\\/result$/.test(s);\n  }\n}\n\nfunction toText(v){\n  if (v == null) return '';\n  if (typeof v === 'string') return v.trim();\n  if (Array.isArray(v)) return v.map(toText).filter(Boolean).join('\\n');\n  if (typeof v === 'object') {\n    // typische Felder aus Agent/Writer/Summary\n    if (Array.isArray(v.tldr) && v.tldr.length) return v.tldr.map(String).join('\\n');\n    if (typeof v.summary === 'string') return v.summary.trim();\n    if (v.summary && Array.isArray(v.summary.tldr)) return v.summary.tldr.map(String).join('\\n');\n    if (typeof v.final === 'string') return v.final.trim();\n    if (typeof v.answer === 'string') return v.answer.trim();\n    try { return JSON.stringify(v, null, 2); } catch { return ''; }\n  }\n  return '';\n}\n\nfunction firstAnswer(...vals){\n  for (const v of vals){\n    const s = toText(v);\n    if (s && !isJobResultUrl(s)) return s;\n  }\n  return '';\n}\n\n// --- Bestehendes Context-Setup ---\nconst init  = $items('Init Round State', 0)?.[0]?.json ?? {};\nconst s     = $json ?? {};\nconst state = s.state || init.state || {};\n\nconst fmt   = $items('Format Agent Response', 0)?.[0]?.json ?? {};\nconst sum   = $items('Summarize Think Blocks (Safe)', 0)?.[0]?.json ?? {};\nconst crit  = $items('Apply Critic Feedback', 0)?.[0]?.json ?? {};\n\n// --- NEU: Antwort robust ziehen (ohne Job-URL, inkl. Objekt-Summary) ---\nconst answer = firstAnswer(\n  // priorisiert: sauber formatiert\n  fmt.answer, fmt.summary, fmt.writer_output,\n  // aus Summarizer\n  sum?.rationale_summary?.tldr, sum?.tldr, sum?.summary,\n  // aus aktuellem Item\n  s.answer, s.text, s.writer_answer, s.writer_output,\n  s.boardPersonaText, s.boardText,\n  // zuletzt NUR wenn es keine /rag/jobs/.../result URL ist:\n  !isJobResultUrl(s.result) ? s.result : ''\n);\n\n// Quellen/Artefakte wie gehabt\nfunction pickArr(...cands){ for (const a of cands) if (Array.isArray(a) && a.length) return a; return []; }\nconst sources = pickArr(fmt.sources, s.sources, s.documents);\n\nconst artifacts = { ...(s.artifacts || {}), ...(fmt.artifacts || {}) };\nif (!artifacts.rationale_summary && sum.rationale_summary) {\n  artifacts.rationale_summary = sum.rationale_summary;\n}\nconst moderatorNotes = firstAnswer(\n  fmt?.artifacts?.moderator_notes,\n  s?.artifacts?.moderator_notes,\n  String(state.boardModeratorNotes || ''),\n  crit?.artifacts?.moderator_notes,\n  crit?.moderator_notes\n);\nif (moderatorNotes) artifacts.moderator_notes = moderatorNotes;\n\n// Rückgabe\nreturn [{\n  json: {\n    answer,\n    sources,\n    artifacts,\n    ok: true,\n    __final: true,\n    job_id: init.job_id ?? s.job_id ?? state.job_id ?? null,\n    conversation_id: init.conversation_id ?? s.conversation_id ?? null,\n    personas: s.personas ?? init.personas ?? [],\n    agent_rounds: s.agent_rounds ?? init.agent_rounds ?? 1,\n    state\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4256,
        192
      ],
      "id": "cdc5f613-baaf-4793-9715-d45c821d26be",
      "name": "Finalize State"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "OjD3jrVzeEsAqnr7",
          "mode": "list",
          "cachedResultName": "Emit Event"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "mode": "each",
        "options": {
          "waitForSubWorkflow": false
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        2912,
        0
      ],
      "id": "4ac3d5c9-6607-4f31-92f7-f6d52fb3ac59",
      "name": "Run emit_event",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const s = item.json;\nconst base = s.__event_base ?? {\n  job_id: s.job_id ?? null,\n  persona: s.persona ?? s.label ?? '',\n  role: s.role ?? '',\n  round: Number(s.round ?? 1),\n  rounds_total: Number(s.agent_rounds ?? 1),\n};\nitem.json.__event = {\n  ...base,\n  stage: 'round_start',\n  message: `Starte Runde ${base.round}/${base.rounds_total}`,\n};\nreturn item;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2688,
        0
      ],
      "id": "f91b1ea2-f6cb-4c63-a451-1c9a8db98efb",
      "name": "Build Event: Round Start"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const s = item.json;\nconst base = s.__event_base ?? {\n  job_id: s.job_id ?? null,\n  persona: s.persona ?? s.label ?? '',\n  role: s.role ?? '',\n  round: Number(s.round ?? 1),\n  rounds_total: Number(s.agent_rounds ?? 1),\n};\nitem.json.__event = {\n  ...base,\n  stage: 'writer',\n  message: 'Schreiberling fasst Team-Ergebnisse zusammen',\n};\nreturn item;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2912,
        192
      ],
      "id": "e3e40f82-dab4-496f-8b31-cf0a9728e521",
      "name": "Build Event: Writer"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "OjD3jrVzeEsAqnr7",
          "mode": "list",
          "cachedResultName": "Emit Event"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "mode": "each",
        "options": {
          "waitForSubWorkflow": false
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        3360,
        336
      ],
      "id": "67221828-c49b-4aad-94b0-ac672b459384",
      "name": "Run emit_event1",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const s = item.json;\nconst base = s.__event_base ?? {\n  job_id: s.job_id ?? null,\n  persona: s.persona ?? s.label ?? '',\n  role: s.role ?? '',\n  round: Number(s.round ?? 1),\n  rounds_total: Number(s.agent_rounds ?? 1),\n};\nitem.json.__event = {\n  ...base,\n  stage: 'critic',\n  message: 'allsehendes Auge wirft einen Blick...',\n};\nreturn item;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        672,
        64
      ],
      "id": "20fb1d93-de31-48e7-81ca-46d195559535",
      "name": "Build Event: Critic"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "OjD3jrVzeEsAqnr7",
          "mode": "list",
          "cachedResultName": "Emit Event"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "mode": "each",
        "options": {
          "waitForSubWorkflow": false
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        896,
        192
      ],
      "id": "9b1c048e-50a8-4ca9-bb23-7c0d3c8a6524",
      "name": "Run emit_event2",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Build Event: Persona Done (Function Item)\nconst s = item.json ?? {};\nconst label = (s.persona ?? s.label ?? 'Persona').toString().replace(/^=+/, '').trim();\n\nitem.json.__event = {\n  job_id: s.job_id ?? null,\n  persona: label,\n  role: s.role ?? '',\n  round: Number(s.round ?? 1),\n  rounds_total: Number(s.agent_rounds ?? 1),\n  stage: 'persona_start',\n  message: `${label} arbeitet an Beitrag...`,\n};\nreturn item;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2016,
        192
      ],
      "id": "5405e9f4-3679-4b23-8ae7-302f81f7b190",
      "name": "Build Event: Persona Start"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "OjD3jrVzeEsAqnr7",
          "mode": "list",
          "cachedResultName": "Emit Event"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "mode": "each",
        "options": {
          "waitForSubWorkflow": false
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        -1792,
        192
      ],
      "id": "360de8f2-d94c-4d25-b0ef-74f26531ac64",
      "name": "Run emit_event3",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Build Event: Persona Done (Function Item)\nconst s = item.json ?? {};\nconst label = (s.persona ?? s.label ?? 'Persona').toString().replace(/^=+/, '').trim();\n\nitem.json.__event = {\n  job_id: s.job_id ?? null,\n  persona: label,\n  role: s.role ?? '',\n  round: Number(s.round ?? 1),\n  rounds_total: Number(s.agent_rounds ?? 1),\n  stage: 'persona_done',\n  message: `fertig – ${label}`,\n};\nreturn item;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1120,
        64
      ],
      "id": "00b4717e-bada-4c58-8969-970a1efd80ff",
      "name": "Build Event: Persona Done"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "OjD3jrVzeEsAqnr7",
          "mode": "list",
          "cachedResultName": "Emit Event"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "mode": "each",
        "options": {
          "waitForSubWorkflow": false
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        -896,
        64
      ],
      "id": "1fc2ee07-8d4d-49a4-b11e-5dd5e61c40a7",
      "name": "Run emit_event4",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -1344,
        64
      ],
      "id": "d8d1cd1a-b998-41fb-aa06-e7bafaae83c0",
      "name": "Collect Data"
    },
    {
      "parameters": {
        "jsCode": "// Inputs: state.thinkPersona, state.thinkWriter\n// Output: artifacts.rationale_summary = { persona: [ {round,label,bullets[]}... ], writer: [bullets[]] }\n\nfunction summarize(lines) {\n  // sehr simple Heuristik: kurze Stichpunkte aus den Zeilen bauen (keine Original-Sätze übernehmen)\n  // -> in der Praxis kannst du hier auch einen LLM-Call mit striktem Prompt nutzen,\n  //    der EXPLIZIT keine Zitate/Schrittfolgen erzeugen darf.\n  const text = lines.join(' ').replace(/\\s+/g,' ').slice(0, 2000);\n  const words = text.split(/\\W+/).filter(Boolean);\n  const freqs = new Map();\n  for (const w of words) {\n    const k = w.toLowerCase();\n    if (k.length < 4) continue;\n    freqs.set(k, (freqs.get(k)||0)+1);\n  }\n  const top = Array.from(freqs.entries()).sort((a,b)=>b[1]-a[1]).slice(0,7).map(([w])=>w);\n  const bullets = top.slice(0,5).map(w => `Hinweis zu: ${w}`);\n  return bullets.length ? bullets : ['(keine verwertbaren Hinweise)'];\n}\n\nconst flow = $json || {};\nconst state = flow.state || {};\nconst persona = Array.isArray(state.thinkPersona) ? state.thinkPersona : [];\nconst writer  = Array.isArray(state.thinkWriter)  ? state.thinkWriter  : [];\n\nconst personaSummary = persona.map(p => ({\n  round: p.round,\n  label: p.label,\n  bullets: summarize([...(p.raw||[])])\n}));\n\nconst writerSummary = writer.length\n  ? summarize(writer.flatMap(x => x.raw || []))\n  : [];\n\nconst artifacts = {\n  ...(flow.artifacts || {}),\n  rationale_summary: {\n    persona: personaSummary,\n    writer: writerSummary\n  }\n};\n\nreturn [{ json: { ...flow, artifacts } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3136,
        192
      ],
      "id": "f87939cb-7293-49b3-a254-9442e96fed3a",
      "name": "Summarize Think Blocks (Safe)"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1344,
        64
      ],
      "id": "0bcfd7dc-a14b-47bd-b590-ccf3a8dadb96",
      "name": "Collect Data1"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        3808,
        192
      ],
      "id": "b901c8ef-789a-4e83-bae5-8d33422052ba",
      "name": "Collect Data2"
    }
  ],
  "pinData": {},
  "connections": {
    "Prepare Persona Items": {
      "main": [
        [
          {
            "node": "Build Event: Persona Start",
            "type": "main",
            "index": 0
          },
          {
            "node": "Collect Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run RAG_Router (Agents)": {
      "main": [
        [
          {
            "node": "Collect Data",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Collect Agent Outputs": {
      "main": [
        [
          {
            "node": "Parse Tool Calls",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run RAG_Router (Writer)": {
      "main": [
        [
          {
            "node": "Collect Data2",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Agents Preflight (Normalize)": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Build Writer Prompt": {
      "main": [
        [
          {
            "node": "Build Event: Writer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Critic Prompt": {
      "main": [
        [
          {
            "node": "Build Event: Critic",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run RAG_Router (Critic)": {
      "main": [
        [
          {
            "node": "Collect Data1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Apply Critic Feedback": {
      "main": [
        [
          {
            "node": "Round Incrementer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Init Round State": {
      "main": [
        [
          {
            "node": "State Manager",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "State Manager": {
      "main": [
        [
          {
            "node": "Loop Checker",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Checker": {
      "main": [
        [
          {
            "node": "Loop Gate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Round Incrementer": {
      "main": [
        [
          {
            "node": "State Manager",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Prepare Persona Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Gate": {
      "main": [
        [
          {
            "node": "Build Event: Round Start",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Writer Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Tool Calls": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Tool Observations": {
      "main": [
        [
          {
            "node": "Prepare Critic Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run Tools Router": {
      "main": [
        [
          {
            "node": "Merge Tool Observations",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Run Tools Router",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Critic Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Subflow": {
      "main": [
        [
          {
            "node": "Agents Preflight (Normalize)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Init Round State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Agent Response": {
      "main": [
        [
          {
            "node": "Finalize State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Event: Round Start": {
      "main": [
        [
          {
            "node": "Run emit_event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Event: Writer": {
      "main": [
        [
          {
            "node": "Summarize Think Blocks (Safe)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Event: Critic": {
      "main": [
        [
          {
            "node": "Run emit_event2",
            "type": "main",
            "index": 0
          },
          {
            "node": "Collect Data1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Event: Persona Start": {
      "main": [
        [
          {
            "node": "Run emit_event3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Event: Persona Done": {
      "main": [
        [
          {
            "node": "Run emit_event4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run emit_event3": {
      "main": [
        [
          {
            "node": "Run RAG_Router (Agents)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run emit_event4": {
      "main": [
        [
          {
            "node": "Collect Agent Outputs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run emit_event2": {
      "main": [
        [
          {
            "node": "Run RAG_Router (Critic)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run emit_event1": {
      "main": [
        [
          {
            "node": "Run RAG_Router (Writer)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run emit_event": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collect Data": {
      "main": [
        [
          {
            "node": "Build Event: Persona Done",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Summarize Think Blocks (Safe)": {
      "main": [
        [
          {
            "node": "Run emit_event1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Collect Data2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collect Data1": {
      "main": [
        [
          {
            "node": "Apply Critic Feedback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collect Data2": {
      "main": [
        [
          {
            "node": "Format Agent Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "feba6763-26d9-46ce-a527-ff072c83445a",
  "meta": {
    "instanceId": "561919f222f248fefb13e03c84adfc7356dad806feb0489acfa0f3688a2a1852"
  },
  "id": "Aiz81noQbgD9M62I",
  "tags": [
    {
      "createdAt": "2025-09-11T13:23:00.506Z",
      "updatedAt": "2025-09-11T13:23:00.506Z",
      "id": "4ZXhh7HxNdYuxid7",
      "name": "Subflow"
    }
  ]
}