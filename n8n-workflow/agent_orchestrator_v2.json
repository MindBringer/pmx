{
  "name": "agent_orchestrator_v2",
  "nodes": [
    {
      "parameters": {
        "jsCode": "// Prepare Persona Items — persona-only board, focus/questions in Prompt, robust provider/model mapping\n\n// --------------- helpers ---------------\nconst norm = v => String(v ?? '').trim();\nconst isArr = a => Array.isArray(a);\n\n// zugelassene Provider für den Router\nconst ALLOWED = new Set(['groq','openai','anthropic','mistralapi','openrouter','huggingface','mistral']);\n\n// Heuristik: aus einem Modellstring den Provider raten\nfunction guessProviderFromModel(m) {\n  const s = norm(m).toLowerCase();\n  if (!s) return '';\n  if (s.includes('claude')) return 'anthropic';\n  if (s.includes('gpt') || s.startsWith('o3') || s.startsWith('o1')) return 'openai';\n  if (s.includes('openai/') || s.includes('/')) return 'openrouter';\n  if (s.includes('mistral') || s.includes('mixtral')) return 'mistral';\n  if (s.includes('llama') || s.includes('gemma') || s.includes('deepseek')) return 'groq';\n  return '';\n}\n\n// Provider/Model zu Router-Feldern mappen (+ Defaults)\nfunction mapProviderModel(providerIn, modelIn) {\n  let prov = norm(providerIn).toLowerCase();\n  let mdl  = norm(modelIn);\n\n  // wenn prov kein erlaubter Provider ist, könnte es das Modell sein\n  if (!ALLOWED.has(prov)) {\n    const guessed = guessProviderFromModel(prov);\n    if (guessed) { mdl = prov; prov = guessed; }\n  }\n  // weiterhin unklar? aus mdl raten\n  if (!ALLOWED.has(prov)) {\n    const guessed = guessProviderFromModel(mdl);\n    if (guessed) prov = guessed;\n  }\n  // finale Defaults\n  if (!ALLOWED.has(prov)) prov = 'groq';\n  if (!mdl) {\n    if (prov === 'groq')        mdl = 'llama-3.1-70b-versatile';\n    else if (prov === 'openai') mdl = 'gpt-4o-mini';\n    else if (prov === 'anthropic') mdl = 'claude-3-5-sonnet';\n    else if (prov === 'mistralapi') mdl = 'mistral-large-latest';\n    else if (prov === 'openrouter') mdl = 'openai/gpt-oss-120b';\n    else if (prov === 'huggingface') mdl = 'meta-llama/Meta-Llama-3-8B-Instruct';\n    else /* mistral (ollama) */ mdl = 'llama3';\n  }\n\n  switch (prov) {\n    case 'groq':        return { model: 'groq',        groq_model: mdl };\n    case 'openai':      return { model: 'openai',      openai_model: mdl };\n    case 'anthropic':   return { model: 'anthropic',   claude_model: mdl };\n    case 'mistralapi':  return { model: 'mistralapi',  mistral_model: mdl };\n    case 'openrouter':  return { model: 'openrouter',  openrouter_model: mdl };\n    case 'huggingface': return { model: 'huggingface', hf_model: mdl };\n    case 'mistral':\n    default:            return { model: 'mistral',     ollama_model: mdl };\n  }\n}\n\n// --------------- input normalize ---------------\nconst root  = ($json && typeof $json === 'object') ? $json : {};\nlet pre = root;\n\n// falls ein Preflight-Node die Personas normalisiert hat, dort abholen\nif (!root.personas && !root.body?.personas) {\n  try {\n    const it = $items(\"Agents Preflight (Normalize)\", 0)[0];\n    if (it && it.json) pre = it.json;\n  } catch {}\n}\n\n// Personas extrahieren\nconst personas =\n  isArr(root.personas) ? root.personas :\n  isArr(pre.personas)  ? pre.personas  :\n  isArr(root.body?.personas) ? root.body.personas :\n  [];\n\n// keine Personas → erklärbares Fehlerobjekt\nif (!isArr(personas) || personas.length === 0) {\n  return [{ json: { error: \"No personas provided\", info: \"Prepare Persona Items erwartet personas[]\" } }];\n}\n\n// State & globale Felder\nconst state     = root.state || {};\nconst task      = norm(root.prompt ?? pre.prompt ?? root.body?.prompt ?? state.task);\nconst globalSys = norm(root.system ?? pre.system ?? root.body?.system);\nconst rag       = !!(root.rag ?? pre.rag ?? root.body?.rag);\nconst rag_tags  = isArr(root.rag_tags ?? pre.rag_tags ?? root.body?.rag_tags) ? (root.rag_tags ?? pre.rag_tags ?? root.body?.rag_tags) : [];\nconst convId    = root.conversation_id ?? pre.conversation_id ?? null;\nconst jobId     = root.job_id ?? pre.job_id ?? root.body?.job_id ?? root.jobId ?? pre.jobId ?? null;\nconst memory    = root.memory ?? pre.memory ?? null;\n\nconst round         = Number(state.round ?? root.round ?? 1);\nconst agent_rounds  = Number(state.rounds_total ?? state.agent_rounds ?? root.agent_rounds ?? pre.agent_rounds ?? 1);\n\n// Persona-only Board als Kontext\nconst boardPersonaText = norm(state.boardPersonaText || root.boardPersonaText || root.boardText);\n\n// Critic-Hinweise nur im Prompt anzeigen (nicht ins Board)\nconst focus = Array.isArray(state.critic_focus) ? state.critic_focus : [];\nconst questions = Array.isArray(state.critic_questions) ? state.critic_questions : [];\n\nconst focusLines = (focus.length ? [`- Beantworte diese Fokusaufgaben:`, ...focus.map(s => `  - ${norm(s)}`)] : []);\nconst questionLines = (questions.length ? [`- Beantworte diese Fragen:`, ...questions.map(s => `  - ${norm(s)}`)] : []);\n\n// --------------- build per-persona items ---------------\nconst items = personas.map((p, idx) => {\n  const label = norm(p.label || `Persona ${idx+1}`);\n  const mapped = mapProviderModel(p.provider, p.model);\n\n  const roleSystem = [globalSys, `Rolle: ${label}.`].filter(Boolean).join('\\n\\n');\n\n  const personaPrompt = [\n    `Teamaufgabe: ${task}`,\n    `Dein Beitrag (Rolle: \"${label}\") in Runde ${round} von ${agent_rounds}:`,\n    `- Liefere einen fokussierten, in sich verständlichen Abschnitt (max. 12 Sätze).`,\n    `- Beziehe dich auf die bisherigen Team-Ergebnisse (nur Persona-Inhalte).`,\n    ...focusLines,\n    ...questionLines,\n    boardPersonaText ? `\\nBisherige Team-Ergebnisse (Persona-Inhalte):\\n${boardPersonaText}` : ''\n  ].filter(Boolean).join('\\n');\n\n  return {\n    json: {\n      ...mapped,                  // <- setzt model + provider-spezifisches Modellfeld\n      label,\n      prompt: personaPrompt,\n      system: roleSystem,\n      rag, rag_tags,\n      conversation_id: convId,\n      memory,\n      round,\n      agent_rounds,\n      // rückwärts-kompatible Felder:\n      board: Array.isArray(root.board) ? root.board : [],\n      boardText: boardPersonaText,\n      job_id: jobId\n    }\n  };\n});\n\nreturn items;\n"
      },
      "id": "4a3f8c68-33a5-4f2a-9cdb-af3c94e32498",
      "name": "Prepare Persona Items",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        288,
        -864
      ]
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "2cmATLhSNBMN3a2H",
          "mode": "list",
          "cachedResultName": "RAG_router_v3"
        },
        "workflowInputs": {
          "mappingMode": "passThrough",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "mode": "each",
        "options": {}
      },
      "id": "af4779a0-d10f-457f-9916-d77c4ea65f99",
      "name": "Run RAG_Router (Agents)",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        960,
        -736
      ]
    },
    {
      "parameters": {
        "jsCode": "// Collect Agent Outputs — persona-only, strip <think>, collect thinkPersona[]\n// Quelle für Rundeninfos aus \"Prepare Persona Items\"\nconst preItems  = $items('Prepare Persona Items', 0);\nconst baseState = preItems?.[0]?.json ?? {};\nconst prevState = $json || {};\nconst state     = { ...baseState, ...prevState };\n\nconst agentResults = $input.all();\n\n// Collect Agent Outputs — persona-only, robust think-extraction\nfunction extractThinkAndClean(s) {\n  const src = String(s || '');\n  const thinks = [];\n\n  // 1) <think>...</think>\n  let clean = src.replace(/<think>([\\s\\S]*?)<\\/think>\\s*/gi, (_, t) => {\n    const seg = String(t || '').trim(); if (seg) thinks.push(seg); return '';\n  });\n\n  // 2) ```think ... ```\n  clean = clean.replace(/```(?:think|thinking|reasoning)[\\t ]*\\n([\\s\\S]*?)```/gi, (_, t) => {\n    const seg = String(t || '').trim(); if (seg) thinks.push(seg); return '';\n  });\n\n  // 3) Markdown-Heading \"### Think ... (bis zum nächsten Heading oder Ende)\"\n  clean = clean.replace(/(^|\\n)#{2,3}\\s*think\\b[\\s\\S]*?(?=(\\n#{2,3}\\s)|$)/gi, (m) => {\n    const seg = m.replace(/^.*?\\n/, '').trim(); if (seg) thinks.push(seg); return '';\n  });\n\n  // 4) \"THINK:\" Block (bis zur nächsten Leerzeile / Heading / Ende)\n  clean = clean.replace(/(^|\\n)think:\\s*([\\s\\S]*?)(?=\\n\\s*\\n|\\n#{1,6}\\s|$)/gi, (_, __, t) => {\n    const seg = String(t || '').trim(); if (seg) thinks.push(seg); return '';\n  });\n\n  return { clean: clean.trim(), thinks };\n}\n\nconst board = agentResults.map(it => {\n  const j   = it.json || {};\n  const raw = (j.text || j.result || '').trim();\n  if (!raw) return null;\n  const { clean, thinks } = extractThinkAndClean(raw);\n  const label    = j.label || j.persona?.label || 'Agent';\n  const provider = j.provider || j.model || j.model_used || '';\n  return { label, text: clean, provider, thinks };\n}).filter(Boolean);\n\nconst boardPersonaText = board.map(b => `### ${b.label}\\n${b.text}`).join('\\n\\n');\n\nconst thinkPersona = Array.isArray(state.thinkPersona) ? state.thinkPersona.slice() : [];\nboard.forEach(b => {\n  if (b.thinks && b.thinks.length) {\n    thinkPersona.push({\n      round: Number(state.round || 1),\n      label: b.label,\n      raw: b.thinks\n    });\n  }\n});\n\nreturn [{\n  json: {\n    ...state,\n    board: board.map(({ thinks, ...rest }) => rest),\n    boardText: boardPersonaText,     // rückwärts-kompatibel\n    boardPersonaText,                // Writer-Material\n    thinkPersona\n  }\n}];\n"
      },
      "id": "8409e106-2b43-42eb-af49-4bd98b50a719",
      "name": "Collect Agent Outputs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1856,
        -864
      ]
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "2cmATLhSNBMN3a2H",
          "mode": "list",
          "cachedResultName": "RAG_router_v3"
        },
        "workflowInputs": {
          "mappingMode": "passThrough",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "id": "551f7f21-2929-42fd-b580-f325e75ad80b",
      "name": "Run RAG_Router (Writer)",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        6112,
        -592
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Format Agent Response — writer-only final text, JSON/Focus/Questions herausziehen, think-strip, Moderator-Notes anhängen\n\nfunction pickStr(...cands){ for (const v of cands) if (typeof v === 'string' && v.trim()) return v.trim(); return ''; }\nfunction get(o, p){ return p.split('.').reduce((a,k)=>(a && a[k] !== undefined ? a[k] : undefined), o); }\nfunction stripThink(s){ return String(s || '').replace(/<think>[\\s\\S]*?<\\/think>\\s*/gi, '').trim(); }\n\n// --- NEW: JSON/Sections erkennen -> in Notes verschieben\nfunction formatNotes(obj){\n  const parts = [];\n  if (obj.summary) parts.push(`### Zusammenfassung (Moderator)\\n${String(obj.summary).trim()}`);\n  if (Array.isArray(obj.focus) && obj.focus.length) parts.push(`### Fokus für die nächste Runde\\n${obj.focus.map(s=>`- ${String(s).trim()}`).join('\\n')}`);\n  if (Array.isArray(obj.questions) && obj.questions.length) parts.push(`### Fragen für die nächste Runde\\n${obj.questions.map(s=>`- ${String(s).trim()}`).join('\\n')}`);\n  return parts.join('\\n\\n');\n}\nfunction tryParseJson(s){\n  try { return JSON.parse(s); } catch { return null; }\n}\nfunction extractEmbeddedModeratorFromText(txt){\n  let out = String(txt || '');\n  let collected = [];\n\n  // 1) ```json ... ```\n  out = out.replace(/```json\\s*([\\s\\S]*?)```/gi, (_, body)=>{\n    const parsed = tryParseJson(String(body||'').trim());\n    if (parsed && (parsed.summary || parsed.focus || parsed.questions)) {\n      const note = formatNotes(parsed);\n      if (note) collected.push(note);\n      return '';\n    }\n    return '';\n  });\n\n  // 2) reines JSON-Objekt als ganzer Text\n  const trimmed = out.trim();\n  if (trimmed.startsWith('{') && trimmed.endsWith('}')) {\n    const parsed = tryParseJson(trimmed);\n    if (parsed && (parsed.summary || parsed.focus || parsed.questions)) {\n      const note = formatNotes(parsed);\n      if (note) collected.push(note);\n      out = '';\n    }\n  }\n\n  // 3) Überschriften/Abschnitte \"Fokus/Fragen\" im Text (LLM-Eigenleistung) entfernen → Notes sammeln\n  function harvestSection(name){\n    // Bis nächste Überschrift (### ...) oder Ende\n    const re = new RegExp(`(^|\\\\n)###\\\\s*${name}\\\\b[\\\\s\\\\S]*?(?=(\\\\n###\\\\s)|$)`, 'gi');\n    out = out.replace(re, (m)=>{\n      const body = m.replace(/^.*?\\n/, '').trim();\n      if (body) {\n        const lines = body.split(/\\r?\\n/).map(s=>s.replace(/^\\s*[-*]\\s?/, '').trim()).filter(Boolean);\n        const obj = (name.toLowerCase().startsWith('fokus')||name.toLowerCase().startsWith('focus'))\n          ? { focus: lines } : { questions: lines };\n        const note = formatNotes(obj);\n        if (note) collected.push(note);\n      }\n      return '';\n    });\n  }\n  harvestSection('Fokus');\n  harvestSection('Focus');\n  harvestSection('Fragen');\n  harvestSection('Questions');\n\n  return { text: out.trim(), notes: collected.filter(Boolean).join('\\n\\n') };\n}\nfunction unwrapWholeTextBrackets(s){\n  // Entfernt nur EIN Paar rund/ eckig, wenn es den GESAMTEN Text umschließt.\n  const t = String(s||'').trim();\n  const m1 = t.match(/^\\(\\s*([\\s\\S]*?)\\s*\\)$/);\n  if (m1) return m1[1].trim();\n  const m2 = t.match(/^\\[\\s*([\\s\\S]*?)\\s*\\]$/);\n  if (m2) return m2[1].trim();\n  return t;\n}\nfunction sanitizeAnswer(s){\n  let out = stripThink(s);\n  // JSON & Sections herausziehen (hier nur der Text; Notes sammeln wir separat)\n  const ex = extractEmbeddedModeratorFromText(out);\n  out = ex.text;\n  // führende/backende Klammern, wenn sie *alles* umschließen\n  out = unwrapWholeTextBrackets(out);\n  // übrig gebliebene ```json```/```...``` Fences ohne Inhalt entsorgen\n  out = out.replace(/```[\\s\\S]*?```/g, '').trim();\n  return { text: out, embeddedNotes: ex.notes };\n}\n\n// --------- Bestehende Flatten-Logik (gekürzt aus deiner Version) ---------\nfunction tryParse(x){ if (typeof x === 'string') { try { return JSON.parse(x); } catch {} } return x; }\nfunction flattenToPayload(data){\n  let cur = data, hops = 0;\n  while (cur && typeof cur === 'object' && !Array.isArray(cur) && cur.result !== undefined && hops < 6){\n    cur.result = tryParse(cur.result);\n    const r = cur.result || {};\n    if (typeof r.answer === 'string' || typeof r.text === 'string' || Array.isArray(r.sources) || r.artifacts) break;\n    cur = r; hops++;\n  }\n  return (cur && typeof cur.result === 'object') ? cur.result : cur;\n}\n\nconst cur         = item.json ?? {};\nconst writerItems = $items('Run RAG_Router (Writer)', 0) || [];\nconst writerRaw   = writerItems[0]?.json || {};\nconst critic      = $items('Apply Critic Feedback', 0)?.[0]?.json ?? {};\n\nconst flatWriter  = flattenToPayload(writerRaw);\nconst flatCur     = flattenToPayload(cur);\n\n// 1) Writer bevorzugt, dann aktuelles Item (KEIN Critic-Fallback)\nconst writerAnswer = pickStr(\n  flatWriter?.answer, flatWriter?.text,\n  get(writerRaw,'result.answer'), get(writerRaw,'result.text'),\n  get(writerRaw,'choices.0.message.content'), get(writerRaw,'choices.0.text'),\n  get(writerRaw,'data.choices.0.message.content')\n);\nconst curAnswer = pickStr(\n  flatCur?.answer, flatCur?.text,\n  get(cur,'result.answer'), get(cur,'result.text'),\n  get(cur,'choices.0.message.content'), get(cur,'choices.0.text'),\n  get(cur,'data.choices.0.message.content')\n);\n\nconst rawText = writerAnswer || curAnswer || '';\nconst { text: cleanText, embeddedNotes } = sanitizeAnswer(rawText);\n\n// 2) Quellen & Artefakte mergen (Writer bevorzugt)\nconst sources =\n  (Array.isArray(cur.sources) && cur.sources) ||\n  (Array.isArray(flatCur?.sources) && flatCur.sources) ||\n  (Array.isArray(writerRaw.sources) && writerRaw.sources) ||\n  (Array.isArray(flatWriter?.sources) && flatWriter.sources) || [];\n\nconst artifacts = {\n  ...(flatCur?.artifacts || {}),\n  ...(cur.artifacts || {}),\n  ...(flatWriter?.artifacts || {}),\n  ...(writerRaw.artifacts || {}),\n};\n\n// 3) Moderator-Notizen aus State + ggf. eingebettete Notes hinzufügen\nconst state = cur.state || writerRaw.state || critic.state || {};\nconst moderatorNotes = String(state.boardModeratorNotes || '').trim();\nconst notesMerged = [ moderatorNotes, embeddedNotes ].filter(Boolean).join('\\n\\n');\nif (notesMerged) artifacts.moderator_notes = notesMerged;\n\n// 4) Setzen — boardText NICHT überschreiben (bleibt Persona-only)\ncur.answer    = cleanText;\ncur.sources   = cur.sources ?? sources;\ncur.artifacts = artifacts;\n\nitem.json = cur;\nreturn item;\n"
      },
      "id": "d8411de4-f532-421f-ac57-a0af730438a9",
      "name": "Format Agent Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        6560,
        -736
      ]
    },
    {
      "parameters": {
        "jsCode": "// Agents Preflight (Normalize) — SINGLE item with personas[]\nconst base = ($json && typeof $json === 'object') ? $json : {};\n\nlet personas = base.personas ?? base.body?.personas ?? [];\nif (typeof personas === 'string') {\n  try { personas = JSON.parse(personas); }\n  catch {\n    personas = personas.split(/\\r?\\n|;|\\|/).map(s => ({ label: s.trim() })).filter(p => p.label);\n  }\n}\nif (!Array.isArray(personas) || personas.length === 0) {\n  personas = [{\n    label: base.persona_label || base.label || 'Agent',\n    provider: base.persona_provider || base.provider || base.model || 'groq',\n    model: base.persona_model || base.openai_model || base.groq_model || base.ollama_model || base.mistral_model || base.hf_model || base.model || 'llama3',\n    system: base.persona_system || base.system || '',\n    prompt: base.persona_prompt || ''\n  }];\n}\n\n// optional: Mapping beibehalten, aber NICHT mehr pro Item ausgeben\nfunction mapProvider(prov, model){\n  const p = String(prov || '').toLowerCase();\n  if (p === 'groq')        return { model: 'groq',       groq_model: model };\n  if (p === 'openai')      return { model: 'openai',     openai_model: model };\n  if (p === 'anthropic')   return { model: 'anthropic',  claude_model: model };\n  if (p === 'mistralapi')  return { model: 'mistralapi', mistral_model: model };\n  if (p === 'openrouter')  return { model: 'openrouter', openrouter_model: model || 'openai/gpt-oss-120b' };\n  if (p === 'huggingface') return { model: 'huggingface', hf_model: model };\n  return { model: 'mistral',  ollama_model: model || 'llama3' };\n}\n\npersonas = personas.map((p, i) => {\n  const prov = p.provider || base.provider || 'groq';\n  const mdl  = p.model || base.model || 'llama3';\n  const mapped = mapProvider(prov, mdl);\n  return { ...p, label: p.label || `Agent ${i+1}`, provider: prov, model: mdl, ...mapped };\n});\n\n// EIN Item mit personas[]\nreturn [{ json: { ...base, personas } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -160,
        -784
      ],
      "id": "c8a0b65d-7075-43a1-be63-d788111f3d36",
      "name": "Agents Preflight (Normalize)"
    },
    {
      "parameters": {
        "jsCode": "// Build Writer Prompt — Persona-only material, strip <think>, promote prompt/system, **carry job_id + __event_base**\n\nconst j = ($json && typeof $json === 'object') ? $json : {};\nconst norm = v => String(v ?? '').trim();\nconst isArr = a => Array.isArray(a);\n\n// ---- Provider/Model (unverändert aus deiner letzten Fassung) ----\nconst allowed = new Set(['groq','openai','anthropic','mistralapi','openrouter','huggingface','mistral']);\nconst provIn  = norm(j.writer?.provider || j.model || j.provider).toLowerCase();\nconst provider = allowed.has(provIn) ? provIn : 'groq';\n\nlet modelFields = {};\nswitch (provider) {\n  case 'groq':       modelFields = { model:'groq',       groq_model: j.groq_model || j.writer?.model || 'llama-3.1-70b-versatile' }; break;\n  case 'openai':     modelFields = { model:'openai',     openai_model: j.openai_model || j.writer?.model || 'gpt-4o-mini'           }; break;\n  case 'anthropic':  modelFields = { model:'anthropic',  claude_model: j.claude_model || j.writer?.model || 'claude-3-5-sonnet'     }; break;\n  case 'mistralapi': modelFields = { model:'mistralapi', mistral_model: j.mistral_model || j.writer?.model || 'mistral-large-latest'}; break;\n  case 'openrouter': modelFields = { model:'openrouter', openrouter_model: j.openrouter_model || j.writer?.model || 'openai/gpt-oss-120b' }; break;\n  case 'huggingface':modelFields = { model:'huggingface',hf_model: j.hf_model || j.writer?.model || 'meta-llama/Meta-Llama-3-8B-Instruct'}; break;\n  case 'mistral':\n  default:           modelFields = { model:'mistral',    ollama_model: j.ollama_model || j.writer?.model || 'llama3'                }; break;\n}\n\n// ---- Persona-only Material + Think-strip (defensiv) ----\nconst stripThink = s => String(s || '').replace(/<think>[\\s\\S]*?<\\/think>\\s*/g,'').trim();\nconst personaBoardRaw =\n  j.boardPersonaText ??\n  (isArr(j.board) ? j.board.map(b=>`### ${b.label||'Agent'}\\n${norm(b.text)}`).join('\\n\\n') : '');\nconst boardPersonaText = stripThink(personaBoardRaw);\nconst basePrompt = j.prompt ?? j.body?.prompt ?? j.input?.prompt ?? '';\n\nconst writerSystem = [\n  (j.system || j.body?.system || ''),\n  'Du bist der **Writer/Redakteur**.',\n  'Erzeuge eine klare, strukturierte Abschlussfassung ausschließlich auf Basis der Persona-Inhalte.',\n  'Ignoriere Moderator-/Critic-Notizen, Tool-/Observation-Texte und interne Denkabschnitte.',\n  'Struktur: 1) Kurzfassung (max. 5 Sätze)  2) Details je Bereich  3) Entscheidungen  4) Offene Punkte / Risiken',\n  'Formatiere mit sinnvollen Überschriften und Listen.'\n].filter(Boolean).join('\\n');\n\nconst writerPrompt = [\n  `Teamaufgabe: ${basePrompt}`,\n  '',\n  'Team-Ergebnisse (nur Persona-Inhalte):',\n  boardPersonaText || '(keine Persona-Inhalte verfügbar)'\n].join('\\n');\n\n// ---- 🔧 job_id + event-base robust übernehmen ----\nconst state = j.state || {};\nconst jobId =\n  j.job_id ??\n  j.jobId ??\n  state.job_id ??\n  j.__event_base?.job_id ??\n  j.__event?.job_id ??\n  j.body?.job_id ??\n  null;\n\n// Runde / Runden\nconst round        = Number(state.round ?? j.round ?? 1);\nconst rounds_total = Number(state.rounds_total ?? state.agent_rounds ?? j.agent_rounds ?? 1);\n\n// __event_base vorbereiten (vom Writer-Branch aus nutzbar)\nconst eventBase = {\n  job_id: jobId,\n  persona: 'Writer',\n  role: 'writer',\n  round,\n  rounds_total\n};\n\n// ---- Promote prompt/system & carry job_id ----\nconst promoted = {\n  ...modelFields,\n  prompt: writerPrompt,\n  system: writerSystem,\n  rag: !!j.rag,\n  rag_tags: isArr(j.rag_tags) ? j.rag_tags : [],\n  conversation_id: j.conversation_id ?? null,\n  memory: j.memory ?? null,\n  job_id: jobId,                 // <<—— WICHTIG: top-level job_id für Subflows\n  __event_base: eventBase        // <<—— WICHTIG: für emit_event-Subflow\n};\n\n// Keep writer_call for logging/debugging\nconst writer_call = { ...promoted };\n\nreturn { json: { ...j, ...promoted, writer_call } };\n"
      },
      "id": "0eb5272d-96d3-4ea0-8fed-afa5a69341c8",
      "name": "Build Writer Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5216,
        -736
      ]
    },
    {
      "parameters": {
        "jsCode": "// Init Round State\nconst j = $json || {};\nconst rounds = Number(j.agent_rounds ?? j.body?.agent_rounds ?? 1);\nreturn [{\n  json: {\n    ...j,\n    round: 1,\n    agent_rounds: Math.max(1, rounds),\n    board: Array.isArray(j.board) ? j.board : [],\n    boardText: String(j.boardText || ''),\n  }\n}];"
      },
      "id": "3390e9b9-e5a9-4cc8-a0b9-9d8acb670c1c",
      "name": "Init Round State",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4320,
        -448
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare Critic/Facilitator Prompt — keine Resets von round/agent_rounds\nconst j = $json || {};\n\n// Provider-Mapping (separat steuerbar über j.critic)\nconst allowed = new Set(['groq','openai','anthropic','mistralapi','openrouter','huggingface','mistral']);\nconst provIn  = String(j.critic?.provider || j.model || j.provider || '').toLowerCase();\nconst provider = allowed.has(provIn) ? provIn : 'groq';\nconst mdlIn   = String(j.critic?.model || '').toLowerCase();\n\nlet mapped = {};\nswitch (provider) {\n  case 'groq':       mapped = { model: 'groq',       groq_model: mdlIn || j.groq_model || 'llama-3.1-70b-versatile' }; break;\n  case 'openai':     mapped = { model: 'openai',     openai_model: mdlIn || j.openai_model || 'gpt-4o-mini' }; break;\n  case 'anthropic':  mapped = { model: 'anthropic',  claude_model: mdlIn || j.claude_model || 'claude-3-5-sonnet' }; break;\n  case 'mistralapi': mapped = { model: 'mistralapi', mistral_model: mdlIn || j.mistral_model || 'mistral-large-latest' }; break;\n  case 'openrouter': mapped = { model: 'openrouter', openrouter_model: mdlIn || j.openrouter_model || 'openai/gpt-oss-120b' }; break;\n  case 'huggingface':mapped = { model: 'huggingface',hf_model: mdlIn || j.hf_model || 'meta-llama/Meta-Llama-3-8B-Instruct' }; break;\n  default:           mapped = { model: 'mistral',    ollama_model: mdlIn || j.ollama_model || 'llama3' };\n}\n\n// State sicher beibehalten\nconst round = Number(j.round ?? 1);\nconst total = Number(j.agent_rounds ?? 1);\n\n// Base-Prompt des Users für Anzeige/Memory konservieren\nconst basePrompt = j._original_prompt ?? j.prompt ?? '';\n\n// Prompt für den Critic\nconst criticSystem = [\n  'Du bist der **Facilitator/Critic** einer Agentenbesprechung.',\n  'Aufgaben:',\n  '- Verdichte die bisherigen Team-Ergebnisse,',\n  '- markiere Widersprüche/Lücken.',\n  '- Stelle 1–3 präzise Fragen an den/die Agent:in (kurz, nummeriert).',\n  '- Formuliere max. 3 konkrete Fokusaufgaben für die nächste Runde,',\n  '- entscheide, ob eine weitere Runde nötig ist (stop=true/false).'\n].join('\\n');\n\nconst boardText = j.boardText || '';\nconst criticUser = [\n  `Aufgabe (User): ${basePrompt}`,\n  '',\n  `Runde ${round} von ${total}`,\n  '',\n  'Bisherige Team-Ergebnisse:',\n  boardText || '(noch keine)',\n  '',\n  'Erwarte JSON: { \"summary\": string, \"focus\": [string], \"questions\": [string], \"stop\": boolean }'\n].join('\\n');\n\nreturn {\n  json: {\n    ...j,\n    ...mapped,\n    // WICHTIG: State-Felder explizit mitgeben\n    round,\n    agent_rounds: total,\n    // Anzeige/Memory: _original_prompt setzen, prompt für den Critic setzen\n    _original_prompt: basePrompt,\n    prompt: criticUser,\n    system: criticSystem\n  }\n};\n"
      },
      "id": "d9f684a0-7546-42e2-b2f7-0456871d0c05",
      "name": "Prepare Critic Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2976,
        -864
      ]
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "2cmATLhSNBMN3a2H",
          "mode": "list",
          "cachedResultName": "RAG_router_v3"
        },
        "workflowInputs": {
          "mappingMode": "passThrough",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "id": "271ea56b-3a1a-45a0-830c-7b6ecba858a0",
      "name": "Run RAG_Router (Critic)",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        3648,
        -736
      ]
    },
    {
      "parameters": {
        "jsCode": "// Apply Critic Feedback — Moderator-Notizen + job_id passthrough\n\nfunction firstValidJson(items) {\n  for (const it of items) {\n    const v = it.json;\n    if (v && (v.summary || v.focus || v.questions || v.stop !== undefined)) return v;\n    try { const p = JSON.parse(String(v||'{}')); if (p && (p.summary || p.focus || p.questions || p.stop !== undefined)) return p; } catch {}\n  }\n  return {};\n}\n\nconst cur    = $json || {};\nconst state0 = cur.state || {};\n// job_id aus allen sinnvollen Quellen zusammensuchen (inkl. Critic-Run)\nconst job_id =\n  cur.job_id ??\n  state0.job_id ??\n  $items('Run RAG_Router (Critic)', 0)?.[0]?.json?.job_id ??\n  $items('Run RAG_Router (Critic)', 0)?.[0]?.json?.state?.job_id ??\n  cur.__event_base?.job_id ??\n  cur.body?.job_id ??\n  null;\n\nconst parsed = firstValidJson(items);\nconst summary   = String(parsed.summary || '').trim();\nconst focus     = Array.isArray(parsed.focus)     ? parsed.focus.map(s=>String(s).trim()).filter(Boolean) : [];\nconst questions = Array.isArray(parsed.questions) ? parsed.questions.map(s=>String(s).trim()).filter(Boolean) : [];\nconst stop      = Boolean(parsed.stop);\n\nconst blocks = [];\nif (summary)          blocks.push(`### Zusammenfassung (Moderator)\\n${summary}`);\nif (focus.length)     blocks.push(`### Fokus für die nächste Runde\\n${focus.map(s=>`- ${s}`).join('\\n')}`);\nif (questions.length) blocks.push(`### Fragen für die nächste Runde\\n${questions.map(s=>`- ${s}`).join('\\n')}`);\n\nconst boardModeratorNotes = [state0.boardModeratorNotes || '', blocks.join('\\n\\n')].filter(Boolean).join('\\n\\n');\n\nconst state = {\n  ...state0,\n  job_id,                       // <<— wichtig\n  critic_summary: summary || undefined,\n  critic_focus: focus,\n  critic_questions: questions,\n  boardModeratorNotes,\n  stop\n};\n\nreturn [{ json: { ...cur, job_id, state } }];\n"
      },
      "id": "2fa88c52-73ad-410d-82fe-80772e7aae38",
      "name": "Apply Critic Feedback",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4096,
        -864
      ]
    },
    {
      "parameters": {
        "jsCode": "// STATE MANAGER NODE – Zentraler Rundenzähler & Event-Basis (ohne Cross-Refs)\n// - Arbeitet ausschließlich mit $input.all()\n// - Keine $items(...) / $node[...] → keine versteckten Abhängigkeiten\n// - Liefert __event_base, damit Event-Nodes nur $json brauchen\n\nconst allItems = $input.all();\n\nfunction normStr(v) {\n  return (typeof v === 'string' ? v : (v == null ? '' : String(v)))\n    .replace(/^=+/, '') // z.B. \"=Barrista\" -> \"Barrista\"\n    .trim();\n}\nfunction pick(...vals) {\n  for (const v of vals) {\n    if (v === undefined || v === null) continue;\n    if (typeof v === 'string' && v.trim() === '') continue;\n    return v;\n  }\n  return undefined;\n}\nfunction pickFromItems(keys) {\n  for (const it of allItems) {\n    const j = it?.json || {};\n    for (const k of keys) {\n      const v = j[k];\n      if (v === undefined || v === null) continue;\n      if (typeof v === 'string' && v.trim() === '') continue;\n      return v;\n    }\n  }\n  return undefined;\n}\nfunction parseJobIdFromUrl(u) {\n  if (typeof u !== 'string') return undefined;\n  const m = u.match(/\\/rag\\/jobs\\/([0-9a-fA-F-]+)/);\n  return m?.[1];\n}\n\nconsole.log('=== STATE MANAGER ===');\nconsole.log(`Received ${allItems.length} items`);\n\nlet currentState = null;\nlet highestRound = 0;\nlet hasBoard = false;\n\n// besten State wählen\nfor (const it of allItems) {\n  const data = it.json || {};\n  const round = Number(data.round || 1);\n  const itemHasBoard = Array.isArray(data.board) && data.board.length > 0;\n  const itemHasCriticFeedback = Object.prototype.hasOwnProperty.call(data, 'stop');\n\n  if (\n    round > highestRound ||\n    (round === highestRound && itemHasBoard && !hasBoard) ||\n    (round === highestRound && itemHasCriticFeedback)\n  ) {\n    highestRound = round;\n    currentState = data;\n    hasBoard = itemHasBoard;\n  }\n}\n\nif (!currentState) {\n  currentState = { round: 1, agent_rounds: 2, board: [], boardText: '', stop: false };\n}\n\n// IDs & Basiswerte aus Items zusammensuchen (ohne Node-Refs)\nconst jobId = pick(\n  currentState.job_id,\n  pickFromItems(['job_id','jobId','id']),\n  parseJobIdFromUrl(pickFromItems(['events','result','complete']))\n) || null;\n\nconst convId = pick(currentState.conversation_id, pickFromItems(['conversation_id','conversationId'])) || null;\n\nconst persona = normStr(pick(currentState.persona, currentState.label, pickFromItems(['persona','label']), ''));\nconst role    = normStr(pick(currentState.role, pickFromItems(['role']), ''));\nconst round   = Number(pick(currentState.round, pickFromItems(['round'])) ?? 1);\nconst rounds  = Number(pick(currentState.agent_rounds, pickFromItems(['agent_rounds','rounds_total','roundsTotal'])) ?? 1);\n\nconst board   = Array.isArray(currentState.board) ? currentState.board : [];\nconst boardText = normStr(pick(currentState.boardText, currentState.answer, pickFromItems(['boardText','answer']), ''));\n\n// Standard-URLs (relativ, Nginx routet)\nconst eventsUrl   = pick(currentState.events,   jobId ? `/rag/jobs/${jobId}/events`   : '');\nconst resultUrl   = pick(currentState.result,   jobId ? `/rag/jobs/${jobId}/result`   : '');\nconst completeUrl = pick(currentState.complete, jobId ? `/rag/jobs/${jobId}/complete` : '');\n\nconst finalState = {\n  ...currentState,\n\n  // Kanonische Felder\n  round,\n  agent_rounds: rounds,\n  board,\n  boardText,\n  stop: Boolean(currentState.stop),\n\n  // IDs\n  job_id: jobId,\n  conversation_id: convId,\n\n  // Persona/Rolle\n  persona,\n  role,\n\n  // Endpunkte\n  events:   eventsUrl,\n  result:   resultUrl,\n  complete: completeUrl,\n\n  // Event-Basis (für Evt-Nodes/emit_event)\n  __event_base: {\n    job_id: jobId,\n    persona,\n    role,\n    round,\n    rounds_total: rounds\n  },\n\n  _state_manager: {\n    picked_from_items: allItems.length,\n    has_board: hasBoard,\n    ts: new Date().toISOString()\n  }\n};\n\n// EXAKT EIN ITEM zurück\nreturn [{ json: finalState }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4544,
        -864
      ],
      "id": "41427986-dd1c-4863-a182-2a758a97d77c",
      "name": "State Manager"
    },
    {
      "parameters": {
        "jsCode": "const j = $json || {};\n\nconst round = Number(j.round || 1);\nconst maxRounds = Number(j.agent_rounds || 1);\nconst criticStop = Boolean(j.stop);\n\n// Einfache Abbruchlogik\nconst shouldContinue = !criticStop && round <= maxRounds;\n\n// Stop-Gründe sammeln\nconst stopReasons = [];\nif (criticStop) stopReasons.push(\"Critic Stop\");\nif (round > maxRounds) stopReasons.push(`Max Rounds (${round}>${maxRounds})`);\n\nconsole.log(`=== LOOP CHECKER ===`);\nconsole.log(`Round: ${round}/${maxRounds}`);\nconsole.log(`Critic Stop: ${criticStop}`);\nconsole.log(`Should Continue: ${shouldContinue}`);\nif (stopReasons.length > 0) {\n  console.log(`Stop Reasons: ${stopReasons.join(', ')}`);\n}\n\nreturn [{\n  json: {\n    ...j,\n    shouldContinue,\n    _loop_info: {\n      round,\n      maxRounds,\n      criticStop,\n      stopReasons: stopReasons.length > 0 ? stopReasons : null,\n      decision: shouldContinue ? 'CONTINUE' : 'STOP',\n      timestamp: new Date().toISOString()\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4768,
        -864
      ],
      "id": "f04a318b-0948-43be-afe6-f32738cd7a4e",
      "name": "Loop Checker"
    },
    {
      "parameters": {
        "jsCode": "// Round Incrementer — collapse to single state & bump round\nconst items = $input.all();\nconst base  = (items[items.length - 1]?.json) || ($json || {});\nconst currentMax = Math.max(...items.map(it => Number(it.json?.round ?? 1)), Number(base.round ?? 1));\nconst total = Number(base.agent_rounds ?? items[0]?.json?.agent_rounds ?? 1);\n\nreturn [{ json: { ...base, round: currentMax + 1, agent_rounds: total } }];\n"
      },
      "id": "3819c219-8ef5-46ee-b0e8-51386deff4f1",
      "name": "Round Incrementer",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4320,
        -864
      ]
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        64,
        -784
      ],
      "id": "7bfbc1fb-fe1e-4090-a3a3-7b8213c3f7df",
      "name": "Merge"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "761fd3b9-13a5-4825-b268-020062e0eac2",
              "leftValue": "={{ $json.shouldContinue === true }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        4992,
        -864
      ],
      "id": "7fb6a304-f7d7-496b-bbef-f18629f3d4f9",
      "name": "Loop Gate"
    },
    {
      "parameters": {
        "jsCode": "// Parse Tool Calls from LLM text — robust, mehrere JSON-Objekte erlaubt\n// Erwartet in den Agenten-Antworten eingebettete Blöcke wie:\n// {\"tool\":\"web.search\",\"input\":{\"query\":\"...\", \"top_k\":3, \"recency_days\":30}}\n// {\"tool\":\"db.query\",\"input\":{\"kind\":\"postgres\",\"conn\":\"cred:pg_ro\",\"sql\":\"SELECT ... LIMIT 25\"}}\n\nconst MAX_CALLS = 3;\n\nfunction extractJsonObjects(s) {\n  const out = [];\n  const text = String(s || \"\");\n  // Simple JSON object finder (tolerant)\n  const regex = /\\{[\\s\\S]*?\\}/g;\n  let m;\n  while ((m = regex.exec(text)) !== null) {\n    try { out.push(JSON.parse(m[0])); } catch {}\n  }\n  return out;\n}\n\nconst items = $input.all();\nconst calls = [];\n\nfor (const it of items) {\n  const j = it.json || {};\n  const raw = j.text || j.result || j.response || \"\";\n  const found = extractJsonObjects(raw).filter(o => o && o.tool && o.input);\n  for (const f of found) calls.push(f);\n}\n\n// Limit & normalize\nconst allowed = calls.slice(0, MAX_CALLS).map((c, i) => ({\n  tool: String(c.tool).toLowerCase().trim(),\n  input: c.input || {},\n  _tool_idx: i + 1\n}));\n\nreturn [{\n  json: {\n    ...($json || {}),\n    tools: allowed,\n    _tools_info: { requested: calls.length, allowed: allowed.length, max: MAX_CALLS }\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2080,
        -864
      ],
      "id": "a025293a-5821-4bcf-b267-6f55cbe0e697",
      "name": "Parse Tool Calls"
    },
    {
      "parameters": {
        "jsCode": "// Merge Tool Observations into State & BoardText\n\n// Aktueller State kommt bei dir aus vorherigen Nodes (z. B. Collect Agent Outputs / State Manager)\nconst state = ($items('Collect Agent Outputs', 0)?.[0]?.json) \n           || ($items('State Manager', 0)?.[0]?.json) \n           || ($json || {});\n\nconst toolsIn = ($json && Array.isArray($json.tool_observations)) ? $json.tool_observations : [];\n\nfunction fmtObs(o, idx) {\n  if (o.tool === 'web.search' && Array.isArray(o.items)) {\n    const lines = o.items.slice(0, 5).map((it,i)=>`- ${it.title || '(ohne Titel)'} — ${it.url || ''}\\n  ${it.snippet ? String(it.snippet).slice(0,240) : ''}`);\n    return `## Tool #${idx+1}: Websuche\\n${lines.join('\\n')}`;\n  }\n  if (o.tool === 'db.query') {\n    const rc = Number(o.rowCount || (o.rows?.length || 0));\n    const sample = Array.isArray(o.rows) ? o.rows.slice(0, 1)[0] : null;\n    return `## Tool #${idx+1}: DB-Query (${rc} Zeilen)\\n` + (sample ? \"Beispiel:\\n\" + JSON.stringify(sample, null, 2) : \"\");\n  }\n  if (o.tool === 'program.run') {\n    const out = String(o.stdout || '').slice(0, 1500);\n    const note = o.truncated ? '\\n[... gekürzt ...]' : '';\n    return `## Tool #${idx+1}: Programm-Ausgabe (Exit ${o.exitCode})\\n${out}${note}`;\n  }\n  return `## Tool #${idx+1}: ${o.tool}\\n${JSON.stringify(o).slice(0, 1000)}`;\n}\n\nconst toolsBlock = toolsIn.length ? `\\n\\n# Werkzeuge\\n${toolsIn.map(fmtObs).join('\\n\\n')}` : \"\";\n\nconst merged = {\n  ...state,\n  tool_observations: toolsIn,\n  boardToolText: [state.boardToolText || '', toolsBlock].filter(Boolean).join('\\n\\n')\n};\n\nreturn [{ json: merged }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2752,
        -928
      ],
      "id": "f5925164-aa96-4a56-ab6d-ffe15feb34c0",
      "name": "Merge Tool Observations"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "7TJSkMtcQ9WBo4YM",
          "mode": "list",
          "cachedResultName": "tools_router_v1"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        2528,
        -928
      ],
      "id": "785f05ea-2008-49bf-aeff-7b378c3d048e",
      "name": "Run Tools Router"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "d5fa0809-dcbe-476c-85d1-b2c512453860",
              "leftValue": "={{ Array.isArray($json.tools) && $json.tools.length > 0 }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2304,
        -864
      ],
      "id": "bedbe805-182e-4a43-874f-fbe40ffb47d0",
      "name": "If"
    },
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -384,
        -720
      ],
      "id": "0ae73f5c-5fca-42b5-9aa6-a6ec974ebfa4",
      "name": "Execute Subflow"
    },
    {
      "parameters": {
        "jsCode": "// Finalize State — direkte UI-Payload (Answer, Sources, Artifacts), inkl. job_id & state-Passthrough\n\nconst init  = $items('Init Round State', 0)?.[0]?.json ?? {};\nconst s     = $json ?? {};\nconst state = s.state || init.state || {};\n\n// Upstream-Quellen (werden ggf. nicht die \"laufenden\" Items sein)\nconst fmt   = $items('Format Agent Response', 0)?.[0]?.json ?? {};                 // enthält bereinigtes answer + artifacts.moderator_notes\nconst sum   = $items('Summarize Think Blocks (Safe)', 0)?.[0]?.json ?? {};         // enthält rationale_summary\nconst crit  = $items('Apply Critic Feedback', 0)?.[0]?.json ?? {};                 // evtl. zusätzliche Notes\n\nfunction pickStr(...vals){\n  for (const v of vals) if (typeof v === 'string' && v.trim()) return v.trim();\n  return '';\n}\nfunction pickArr(...cands){\n  for (const a of cands) if (Array.isArray(a) && a.length) return a;\n  return [];\n}\n\n// 1) Antwort priorisieren: Format Agent Response → aktuelles Item → Fallbacks\nconst answer = pickStr(\n  fmt.answer,\n  s.answer, s.text, s.writer_answer,\n  (typeof s.result === 'string' ? s.result : ''),\n  s.boardPersonaText, s.boardText\n);\n\n// 2) Quellen priorisieren: Format Agent Response → aktuelles Item\nconst sources = pickArr(fmt.sources, s.sources, s.documents);\n\n// 3) Artefakte mergen (nicht überschreiben, sondern auffüllen)\nconst artifacts = {\n  ...(s.artifacts || {}),\n  ...(fmt.artifacts || {}),\n};\n\n// 3a) Rationale Summary aus Summarizer fallbacken, falls nicht da\nif (!artifacts.rationale_summary && sum.rationale_summary) {\n  artifacts.rationale_summary = sum.rationale_summary;\n}\n\n// 3b) Moderator-/Critic-Notizen einsammeln (mehrere mögliche Ursprünge)\nconst moderatorNotes = pickStr(\n  fmt?.artifacts?.moderator_notes,\n  s?.artifacts?.moderator_notes,\n  String(state.boardModeratorNotes || ''),\n  crit?.artifacts?.moderator_notes,\n  crit?.moderator_notes\n);\nif (moderatorNotes) artifacts.moderator_notes = moderatorNotes;\n\n// Leere Notes entfernen, damit kein leerer Akkordeon angezeigt wird\nif (artifacts.moderator_notes && !String(artifacts.moderator_notes).trim()) {\n  delete artifacts.moderator_notes;\n}\n\n// 4) Rückgabe im UI-Contract\nreturn [{\n  json: {\n    answer,\n    sources,\n    artifacts,\n\n    ok: true,\n    __final: true,\n    job_id: init.job_id ?? s.job_id ?? state.job_id ?? null,\n    conversation_id: init.conversation_id ?? s.conversation_id ?? null,\n    personas: s.personas ?? init.personas ?? [],\n    agent_rounds: s.agent_rounds ?? init.agent_rounds ?? 1,\n    state\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        6784,
        -736
      ],
      "id": "146349ae-bfda-4e01-a568-2ca23a21a567",
      "name": "Finalize State"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "gTyBULqGMjgEgoHd",
          "mode": "list",
          "cachedResultName": "emit_event"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "mode": "each",
        "options": {
          "waitForSubWorkflow": false
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        5440,
        -928
      ],
      "id": "ad6f7ceb-e444-4cca-bdbf-c991338ff261",
      "name": "Run emit_event",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const s = item.json;\nconst base = s.__event_base ?? {\n  job_id: s.job_id ?? null,\n  persona: s.persona ?? s.label ?? '',\n  role: s.role ?? '',\n  round: Number(s.round ?? 1),\n  rounds_total: Number(s.agent_rounds ?? 1),\n};\nitem.json.__event = {\n  ...base,\n  stage: 'round_start',\n  message: `Starte Runde ${base.round}/${base.rounds_total}`,\n};\nreturn item;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5216,
        -928
      ],
      "id": "a63e523f-5686-4047-8998-ae76706b6af0",
      "name": "Build Event: Round Start"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const s = item.json;\nconst base = s.__event_base ?? {\n  job_id: s.job_id ?? null,\n  persona: s.persona ?? s.label ?? '',\n  role: s.role ?? '',\n  round: Number(s.round ?? 1),\n  rounds_total: Number(s.agent_rounds ?? 1),\n};\nitem.json.__event = {\n  ...base,\n  stage: 'writer',\n  message: 'Schreiberling fasst Team-Ergebnisse zusammen',\n};\nreturn item;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5440,
        -736
      ],
      "id": "e0c9b077-de4b-4947-8b22-3d773b1f0a3b",
      "name": "Build Event: Writer"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "gTyBULqGMjgEgoHd",
          "mode": "list",
          "cachedResultName": "emit_event"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "mode": "each",
        "options": {
          "waitForSubWorkflow": false
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        5888,
        -592
      ],
      "id": "18975f28-ed63-4062-929b-7dfa3c0a25f2",
      "name": "Run emit_event1",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const s = item.json;\nconst base = s.__event_base ?? {\n  job_id: s.job_id ?? null,\n  persona: s.persona ?? s.label ?? '',\n  role: s.role ?? '',\n  round: Number(s.round ?? 1),\n  rounds_total: Number(s.agent_rounds ?? 1),\n};\nitem.json.__event = {\n  ...base,\n  stage: 'critic',\n  message: 'allsehendes Auge wirft einen Blick...',\n};\nreturn item;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3200,
        -864
      ],
      "id": "f99cafff-ddd3-4c79-ac2b-2e3f3fbf1be0",
      "name": "Build Event: Critic"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "gTyBULqGMjgEgoHd",
          "mode": "list",
          "cachedResultName": "emit_event"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "mode": "each",
        "options": {
          "waitForSubWorkflow": false
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        3424,
        -736
      ],
      "id": "d14a826c-4538-46f2-b416-6230be243aab",
      "name": "Run emit_event2",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Build Event: Persona Done (Function Item)\nconst s = item.json ?? {};\nconst label = (s.persona ?? s.label ?? 'Persona').toString().replace(/^=+/, '').trim();\n\nitem.json.__event = {\n  job_id: s.job_id ?? null,\n  persona: label,\n  role: s.role ?? '',\n  round: Number(s.round ?? 1),\n  rounds_total: Number(s.agent_rounds ?? 1),\n  stage: 'persona_start',\n  message: `${label} arbeitet an Beitrag...`,\n};\nreturn item;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        512,
        -736
      ],
      "id": "c991d9b4-261e-4361-b6dd-f28c7cca5f9c",
      "name": "Build Event: Persona Start"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "gTyBULqGMjgEgoHd",
          "mode": "list",
          "cachedResultName": "emit_event"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "mode": "each",
        "options": {
          "waitForSubWorkflow": false
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        736,
        -736
      ],
      "id": "9c61cce9-d4ea-4f74-a51d-9b059b287600",
      "name": "Run emit_event3",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Build Event: Persona Done (Function Item)\nconst s = item.json ?? {};\nconst label = (s.persona ?? s.label ?? 'Persona').toString().replace(/^=+/, '').trim();\n\nitem.json.__event = {\n  job_id: s.job_id ?? null,\n  persona: label,\n  role: s.role ?? '',\n  round: Number(s.round ?? 1),\n  rounds_total: Number(s.agent_rounds ?? 1),\n  stage: 'persona_done',\n  message: `fertig – ${label}`,\n};\nreturn item;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1408,
        -864
      ],
      "id": "8075d855-79dc-4462-aeba-172582735b4d",
      "name": "Build Event: Persona Done"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "gTyBULqGMjgEgoHd",
          "mode": "list",
          "cachedResultName": "emit_event"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "mode": "each",
        "options": {
          "waitForSubWorkflow": false
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        1632,
        -864
      ],
      "id": "eed89c6b-1bab-4ea0-8b01-b2f3eeed6d1d",
      "name": "Run emit_event4",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1184,
        -864
      ],
      "id": "8cae806d-41bb-46aa-acea-989a4b57263f",
      "name": "Collect Data"
    },
    {
      "parameters": {
        "jsCode": "// Inputs: state.thinkPersona, state.thinkWriter\n// Output: artifacts.rationale_summary = { persona: [ {round,label,bullets[]}... ], writer: [bullets[]] }\n\nfunction summarize(lines) {\n  // sehr simple Heuristik: kurze Stichpunkte aus den Zeilen bauen (keine Original-Sätze übernehmen)\n  // -> in der Praxis kannst du hier auch einen LLM-Call mit striktem Prompt nutzen,\n  //    der EXPLIZIT keine Zitate/Schrittfolgen erzeugen darf.\n  const text = lines.join(' ').replace(/\\s+/g,' ').slice(0, 2000);\n  const words = text.split(/\\W+/).filter(Boolean);\n  const freqs = new Map();\n  for (const w of words) {\n    const k = w.toLowerCase();\n    if (k.length < 4) continue;\n    freqs.set(k, (freqs.get(k)||0)+1);\n  }\n  const top = Array.from(freqs.entries()).sort((a,b)=>b[1]-a[1]).slice(0,7).map(([w])=>w);\n  const bullets = top.slice(0,5).map(w => `Hinweis zu: ${w}`);\n  return bullets.length ? bullets : ['(keine verwertbaren Hinweise)'];\n}\n\nconst flow = $json || {};\nconst state = flow.state || {};\nconst persona = Array.isArray(state.thinkPersona) ? state.thinkPersona : [];\nconst writer  = Array.isArray(state.thinkWriter)  ? state.thinkWriter  : [];\n\nconst personaSummary = persona.map(p => ({\n  round: p.round,\n  label: p.label,\n  bullets: summarize([...(p.raw||[])])\n}));\n\nconst writerSummary = writer.length\n  ? summarize(writer.flatMap(x => x.raw || []))\n  : [];\n\nconst artifacts = {\n  ...(flow.artifacts || {}),\n  rationale_summary: {\n    persona: personaSummary,\n    writer: writerSummary\n  }\n};\n\nreturn [{ json: { ...flow, artifacts } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5664,
        -736
      ],
      "id": "63fce752-65a9-4529-afd4-7d3aba659d51",
      "name": "Summarize Think Blocks (Safe)"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        3872,
        -864
      ],
      "id": "47ac4980-4fc1-4e3f-a7d8-ca2840f8ecae",
      "name": "Collect Data1"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        6336,
        -736
      ],
      "id": "aff5d592-6d82-4309-94e5-c25a70cdf73a",
      "name": "Collect Data2"
    }
  ],
  "pinData": {},
  "connections": {
    "Prepare Persona Items": {
      "main": [
        [
          {
            "node": "Build Event: Persona Start",
            "type": "main",
            "index": 0
          },
          {
            "node": "Collect Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run RAG_Router (Agents)": {
      "main": [
        [
          {
            "node": "Collect Data",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Collect Agent Outputs": {
      "main": [
        [
          {
            "node": "Parse Tool Calls",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run RAG_Router (Writer)": {
      "main": [
        [
          {
            "node": "Collect Data2",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Agents Preflight (Normalize)": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Build Writer Prompt": {
      "main": [
        [
          {
            "node": "Build Event: Writer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Critic Prompt": {
      "main": [
        [
          {
            "node": "Build Event: Critic",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run RAG_Router (Critic)": {
      "main": [
        [
          {
            "node": "Collect Data1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Apply Critic Feedback": {
      "main": [
        [
          {
            "node": "Round Incrementer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Init Round State": {
      "main": [
        [
          {
            "node": "State Manager",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "State Manager": {
      "main": [
        [
          {
            "node": "Loop Checker",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Checker": {
      "main": [
        [
          {
            "node": "Loop Gate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Round Incrementer": {
      "main": [
        [
          {
            "node": "State Manager",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Prepare Persona Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Gate": {
      "main": [
        [
          {
            "node": "Build Event: Round Start",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Writer Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Tool Calls": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Tool Observations": {
      "main": [
        [
          {
            "node": "Prepare Critic Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run Tools Router": {
      "main": [
        [
          {
            "node": "Merge Tool Observations",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Run Tools Router",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Critic Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Subflow": {
      "main": [
        [
          {
            "node": "Agents Preflight (Normalize)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Init Round State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Agent Response": {
      "main": [
        [
          {
            "node": "Finalize State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Finalize State": {
      "main": [
        []
      ]
    },
    "Build Event: Round Start": {
      "main": [
        [
          {
            "node": "Run emit_event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Event: Writer": {
      "main": [
        [
          {
            "node": "Summarize Think Blocks (Safe)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Event: Critic": {
      "main": [
        [
          {
            "node": "Run emit_event2",
            "type": "main",
            "index": 0
          },
          {
            "node": "Collect Data1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Event: Persona Start": {
      "main": [
        [
          {
            "node": "Run emit_event3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Event: Persona Done": {
      "main": [
        [
          {
            "node": "Run emit_event4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run emit_event3": {
      "main": [
        [
          {
            "node": "Run RAG_Router (Agents)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run emit_event4": {
      "main": [
        [
          {
            "node": "Collect Agent Outputs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run emit_event2": {
      "main": [
        [
          {
            "node": "Run RAG_Router (Critic)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run emit_event1": {
      "main": [
        [
          {
            "node": "Run RAG_Router (Writer)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run emit_event": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collect Data": {
      "main": [
        [
          {
            "node": "Build Event: Persona Done",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Summarize Think Blocks (Safe)": {
      "main": [
        [
          {
            "node": "Run emit_event1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Collect Data2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collect Data1": {
      "main": [
        [
          {
            "node": "Apply Critic Feedback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collect Data2": {
      "main": [
        [
          {
            "node": "Format Agent Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "8ca13a81-60b4-4930-a0fb-5f190410975a",
  "meta": {
    "instanceId": "5e9f1d1029083353f9423560cb0b3070390ad03855815e064cf1d2e50cd094b4"
  },
  "id": "sbK9V2KSnyb2GGxG",
  "tags": [
    {
      "createdAt": "2025-08-15T08:00:40.082Z",
      "updatedAt": "2025-08-15T08:00:40.082Z",
      "id": "MIGc52SFD5ylOxsf",
      "name": "Subflow"
    }
  ]
}