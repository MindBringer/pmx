{
  "name": "agent_orchestrator_v2",
  "nodes": [
    {
      "parameters": {
        "jsCode": "// Prepare Persona Items — LOOP-AWARE (n8n JS v2)\nconst base = ($json && typeof $json === 'object') ? $json : {};\nlet pre = base;\nif (!base.personas && !base.body?.personas) {\n  try {\n    const it = $items(\"Agents Preflight (Normalize)\", 0)[0];\n    if (it && it.json) pre = it.json;\n  } catch {}\n}\nconst b = pre.body || {};\nlet personas = Array.isArray(pre.personas) ? pre.personas\n             : Array.isArray(b.personas)   ? b.personas\n             : [];\nif (!Array.isArray(personas) || personas.length === 0) {\n  return [{ json: { error: \"No personas provided\", info: \"Prepare Persona Items erwartet personas[]\" } }];\n}\nfunction mapProvider(provider, model){\n  const prov = String(provider || 'mistral').toLowerCase();\n  const mdl  = String(model || '').toLowerCase();\n  if (prov === 'openrouter')  return { model: 'openrouter',  openrouter_model: mdl || 'openai/gpt-oss-120b' };\n  if (prov === 'groq')        return { model: 'groq',        groq_model: mdl || 'deepseek-r1-distill-llama-70b' };\n  if (prov === 'mistralapi')  return { model: 'mistralapi',  mistral_model: mdl || 'codestral-2501' };\n  if (prov === 'openai')      return { model: 'openai',      openai_model: mdl || 'gpt-4o-mini' };\n  if (prov === 'anthropic')   return { model: 'anthropic',   claude_model: mdl || 'claude-3-5-sonnet-20240620' };\n  if (prov === 'huggingface') return { model: 'huggingface', hf_model: mdl || 'microsoft/DialoGPT-medium' };\n  return { model: 'mistral',  ollama_model: mdl || 'llama3' };\n}\nconst task      = String(base.prompt ?? pre.prompt ?? b.prompt ?? '').trim();\nconst globalSys = String(base.system ?? pre.system ?? b.system ?? '').trim();\nconst rag       = !!(base.rag ?? pre.rag ?? b.rag);\nconst rag_tags  = Array.isArray(base.rag_tags ?? pre.rag_tags ?? b.rag_tags) ? (base.rag_tags ?? pre.rag_tags ?? b.rag_tags) : [];\nconst convId    = base.conversation_id ?? pre.conversation_id ?? null;\nconst jobId     = base.job_id ?? pre.job_id ?? b.job_id ?? base.jobId ?? pre.jobId ?? null;\nconst memory    = base.memory ?? pre.memory ?? null;\nconst round          = Number(base.round ?? 1);\nconst agent_rounds   = Number(base.agent_rounds ?? pre.agent_rounds ?? 1);\nconst boardText      = base.boardText || '';\nconst board          = Array.isArray(base.board) ? base.board : [];\nconst items = personas.map((p, idx) => {\n  const label = String(p.label || `Persona ${idx+1}`).trim();\n  const mapped = mapProvider(p.provider, p.model);\n  const roleSystem = [globalSys, `Rolle: ${label}.`].filter(Boolean).join('\\n\\n');\n  const personaPrompt = [\n    `Teamaufgabe: ${task}`,\n    `Dein Beitrag:`,\n    `- Runde ${round} von ${agent_rounds}.`,\n    `- Liefere einen fokussierten Abschnitt aus Sicht der Rolle \"${label}\".`,\n    `- Max. 12 Sätze.`,\n    `- Beziehe dich auf die bisherigen Team-Ergebnisse.`\n  ].join('\\n') + (boardText ? `\\n\\nBisherige Team-Ergebnisse:\\n${boardText}` : '');\n  return {\n    json: {\n      ...mapped,\n      label,\n      prompt: personaPrompt,\n      system: roleSystem,\n      rag, rag_tags,\n      conversation_id: convId,\n      memory,\n      round,\n      agent_rounds,\n      board, boardText,\n      job_id: jobId\n    }\n  };\n});\nreturn items;"
      },
      "id": "4a3f8c68-33a5-4f2a-9cdb-af3c94e32498",
      "name": "Prepare Persona Items",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        288,
        -624
      ]
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "2cmATLhSNBMN3a2H",
          "mode": "list",
          "cachedResultName": "RAG_router_v3"
        },
        "workflowInputs": {
          "mappingMode": "passThrough",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "mode": "each",
        "options": {}
      },
      "id": "af4779a0-d10f-457f-9916-d77c4ea65f99",
      "name": "Run RAG_Router (Agents)",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        960,
        -624
      ]
    },
    {
      "parameters": {
        "jsCode": "// Aggregate Board — State aus Prepare Persona Items holen (nicht aus Subflow-Output)\nconst agentResults = $input.all();\n\n// Ersten Input-Item der \"Prepare Persona Items\" nehmen – dort sind round/agent_rounds sicher vorhanden\nconst preItems = $items('Prepare Persona Items', 0);\nconst state = preItems?.[0]?.json ?? {};\n\n// Board aus den Subflow-Ergebnissen bauen\nconst board = agentResults.map(it => {\n  const j = it.json || {};\n  const txt = (j.text || j.result || '').trim();\n  if (!txt) return null;\n  return {\n    label: j.label || j.persona?.label || 'Agent',\n    text: txt,\n    provider: j.provider || j.model || j.model_used || ''\n  };\n}).filter(Boolean);\n\nconst boardText = board.map(b => `### ${b.label}\\n${b.text}`).join('\\n\\n');\n\nreturn [{\n  json: {\n    ...state,     // <- round/agent_rounds zuverlässig behalten\n    board,\n    boardText\n  }\n}];\n"
      },
      "id": "8409e106-2b43-42eb-af49-4bd98b50a719",
      "name": "Collect Agent Outputs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1840,
        -624
      ]
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "2cmATLhSNBMN3a2H",
          "mode": "list",
          "cachedResultName": "RAG_router_v3"
        },
        "workflowInputs": {
          "mappingMode": "passThrough",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "id": "551f7f21-2929-42fd-b580-f325e75ad80b",
      "name": "Run RAG_Router (Writer)",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        5648,
        -496
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Format Agent Response  (Function Item)\n\nfunction pickStr(...cands) {\n  for (const v of cands) if (typeof v === 'string' && v.trim()) return v.trim();\n  return '';\n}\nfunction get(o, p) {\n  return p.split('.').reduce((a, k) => (a && a[k] !== undefined ? a[k] : undefined), o);\n}\n\nconst cur    = item.json ?? {};\nconst writer = $items('Run RAG_Router (Writer)', 0)?.[0]?.json ?? {};\nconst critic = $items('Apply Critic Feedback', 0)?.[0]?.json ?? {};\n\nconst text = pickStr(\n  cur.answer, cur.boardText, cur.writer_text, cur.output, cur.message, cur.response, cur.completion, cur.text,\n  get(cur, 'result.text'),\n  get(cur, 'choices.0.message.content'),\n  get(cur, 'choices.0.text'),\n  get(cur, 'data.choices.0.message.content'),\n  writer.answer, writer.boardText, writer.output, writer.message, writer.response, writer.completion, writer.text,\n  get(writer, 'result.text'),\n  get(writer, 'choices.0.message.content'),\n  get(writer, 'choices.0.text'),\n  get(writer, 'data.choices.0.message.content'),\n  critic.answer, critic.boardText, critic.output, critic.message,\n  get(critic, 'choices.0.message.content')\n);\n\n// Werte setzen\ncur.answer    = text;\ncur.boardText = text;\ncur.sources   = cur.sources ?? cur.documents ?? writer.sources ?? [];\ncur.artifacts = cur.artifacts ?? writer.artifacts ?? {};\n\nitem.json = cur;\nreturn item;       // <— EIN Item zurückgeben, kein Array\n"
      },
      "id": "d8411de4-f532-421f-ac57-a0af730438a9",
      "name": "Format Agent Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5872,
        -496
      ]
    },
    {
      "parameters": {
        "jsCode": "// Agents Preflight (Normalize) — SINGLE item with personas[]\nconst base = ($json && typeof $json === 'object') ? $json : {};\n\nlet personas = base.personas ?? base.body?.personas ?? [];\nif (typeof personas === 'string') {\n  try { personas = JSON.parse(personas); }\n  catch {\n    personas = personas.split(/\\r?\\n|;|\\|/).map(s => ({ label: s.trim() })).filter(p => p.label);\n  }\n}\nif (!Array.isArray(personas) || personas.length === 0) {\n  personas = [{\n    label: base.persona_label || base.label || 'Agent',\n    provider: base.persona_provider || base.provider || base.model || 'groq',\n    model: base.persona_model || base.openai_model || base.groq_model || base.ollama_model || base.mistral_model || base.hf_model || base.model || 'llama3',\n    system: base.persona_system || base.system || '',\n    prompt: base.persona_prompt || ''\n  }];\n}\n\n// optional: Mapping beibehalten, aber NICHT mehr pro Item ausgeben\nfunction mapProvider(prov, model){\n  const p = String(prov || '').toLowerCase();\n  if (p === 'groq')        return { model: 'groq',       groq_model: model };\n  if (p === 'openai')      return { model: 'openai',     openai_model: model };\n  if (p === 'anthropic')   return { model: 'anthropic',  claude_model: model };\n  if (p === 'mistralapi')  return { model: 'mistralapi', mistral_model: model };\n  if (p === 'openrouter')  return { model: 'openrouter', openrouter_model: model || 'openai/gpt-oss-120b' };\n  if (p === 'huggingface') return { model: 'huggingface', hf_model: model };\n  return { model: 'mistral',  ollama_model: model || 'llama3' };\n}\n\npersonas = personas.map((p, i) => {\n  const prov = p.provider || base.provider || 'groq';\n  const mdl  = p.model || base.model || 'llama3';\n  const mapped = mapProvider(prov, mdl);\n  return { ...p, label: p.label || `Agent ${i+1}`, provider: prov, model: mdl, ...mapped };\n});\n\n// EIN Item mit personas[]\nreturn [{ json: { ...base, personas } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -160,
        -544
      ],
      "id": "c8a0b65d-7075-43a1-be63-d788111f3d36",
      "name": "Agents Preflight (Normalize)"
    },
    {
      "parameters": {
        "jsCode": "// Build Writer Prompt — align with Agents & promote prompt/system to top-level\nconst j = ($json && typeof $json === 'object') ? $json : {};\n\n// Allowed providers; default to 'groq' like Agents\nconst allowed = new Set(['groq','openai','anthropic','mistralapi','openrouter','huggingface','mistral']);\nconst provIn  = String(j.writer?.provider || j.model || j.provider || '').toLowerCase();\nconst provider = allowed.has(provIn) ? provIn : 'groq';\n\n// Map to provider-specific model field (reuse existing where possible)\nlet modelFields = {};\nswitch (provider) {\n  case 'groq':\n    modelFields = { model: 'groq',       groq_model: j.groq_model || j.writer?.model || 'llama-3.1-70b-versatile' };\n    break;\n  case 'openai':\n    modelFields = { model: 'openai',     openai_model: j.openai_model || j.writer?.model || 'gpt-4o-mini' };\n    break;\n  case 'anthropic':\n    modelFields = { model: 'anthropic',  claude_model: j.claude_model || j.writer?.model || 'claude-3-5-sonnet' };\n    break;\n  case 'mistralapi':\n    modelFields = { model: 'mistralapi', mistral_model: j.mistral_model || j.writer?.model || 'mistral-large-latest' };\n    break;\n  case 'openrouter':\n    modelFields = { model: 'openrouter', openrouter_model: j.openrouter_model || j.writer?.model || 'openai/gpt-oss-120b' };\n    break;\n  case 'huggingface':\n    modelFields = { model: 'huggingface', hf_model: j.hf_model || j.writer?.model || 'meta-llama/Meta-Llama-3-8B-Instruct' };\n    break;\n  case 'mistral':\n  default:\n    modelFields = { model: 'mistral',    ollama_model: j.ollama_model || j.writer?.model || 'llama3' };\n    break;\n}\n\n// Collect agent outputs for board\nconst boardText = j.boardText || (\n  Array.isArray(j.board)\n    ? j.board.map(b => `### ${b.label || 'Agent'}\\n${(b.text||'').trim()}\\n`).join('\\n')\n    : ''\n);\n\n// Base prompt fallback from multiple common places\nconst basePrompt = j.prompt ?? j.body?.prompt ?? j.input?.prompt ?? '';\n\n// Compose writer prompts\nconst writerSystem = [\n  (j.system || j.body?.system || ''),\n  'Du bist der **Writer**. Fasse die Team-Ergebnisse präzise zusammen.',\n  'Struktur:',\n  '1) Kurzfassung (5 Sätze)',\n  '2) Details je Bereich (Rollenabschnitte)',\n  '3) Entscheidungen',\n  '4) Offene Punkte / Risiken',\n  'Formatiere mit Überschriften und Listen, wo sinnvoll.'\n].filter(Boolean).join('\\n');\n\nconst writerPrompt = [\n  `Teamaufgabe: ${basePrompt}`,\n  '',\n  'Team-Ergebnisse:',\n  boardText\n].join('\\n');\n\n// Promote prompt/system to TOP-LEVEL for passThrough to RAG_Router\nconst promoted = {\n  ...modelFields,\n  prompt: writerPrompt,\n  system: writerSystem,\n  rag: !!j.rag,\n  rag_tags: Array.isArray(j.rag_tags) ? j.rag_tags : [],\n  conversation_id: j.conversation_id ?? null,\n  memory: j.memory ?? null,\n};\n\n// Keep writer_call for logging/debugging\nconst writer_call = { ...promoted };\n\nreturn { json: { ...j, ...promoted, writer_call } };\n"
      },
      "id": "0eb5272d-96d3-4ea0-8fed-afa5a69341c8",
      "name": "Build Writer Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4976,
        -496
      ]
    },
    {
      "parameters": {
        "jsCode": "// Init Round State\nconst j = $json || {};\nconst rounds = Number(j.agent_rounds ?? j.body?.agent_rounds ?? 1);\nreturn [{\n  json: {\n    ...j,\n    round: 1,\n    agent_rounds: Math.max(1, rounds),\n    board: Array.isArray(j.board) ? j.board : [],\n    boardText: String(j.boardText || ''),\n  }\n}];"
      },
      "id": "3390e9b9-e5a9-4cc8-a0b9-9d8acb670c1c",
      "name": "Init Round State",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3872,
        -208
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare Critic/Facilitator Prompt — keine Resets von round/agent_rounds\nconst j = $json || {};\n\n// Provider-Mapping (separat steuerbar über j.critic)\nconst allowed = new Set(['groq','openai','anthropic','mistralapi','openrouter','huggingface','mistral']);\nconst provIn  = String(j.critic?.provider || j.model || j.provider || '').toLowerCase();\nconst provider = allowed.has(provIn) ? provIn : 'groq';\nconst mdlIn   = String(j.critic?.model || '').toLowerCase();\n\nlet mapped = {};\nswitch (provider) {\n  case 'groq':       mapped = { model: 'groq',       groq_model: mdlIn || j.groq_model || 'llama-3.1-70b-versatile' }; break;\n  case 'openai':     mapped = { model: 'openai',     openai_model: mdlIn || j.openai_model || 'gpt-4o-mini' }; break;\n  case 'anthropic':  mapped = { model: 'anthropic',  claude_model: mdlIn || j.claude_model || 'claude-3-5-sonnet' }; break;\n  case 'mistralapi': mapped = { model: 'mistralapi', mistral_model: mdlIn || j.mistral_model || 'mistral-large-latest' }; break;\n  case 'openrouter': mapped = { model: 'openrouter', openrouter_model: mdlIn || j.openrouter_model || 'openai/gpt-oss-120b' }; break;\n  case 'huggingface':mapped = { model: 'huggingface',hf_model: mdlIn || j.hf_model || 'meta-llama/Meta-Llama-3-8B-Instruct' }; break;\n  default:           mapped = { model: 'mistral',    ollama_model: mdlIn || j.ollama_model || 'llama3' };\n}\n\n// State sicher beibehalten\nconst round = Number(j.round ?? 1);\nconst total = Number(j.agent_rounds ?? 1);\n\n// Base-Prompt des Users für Anzeige/Memory konservieren\nconst basePrompt = j._original_prompt ?? j.prompt ?? '';\n\n// Prompt für den Critic\nconst criticSystem = [\n  'Du bist der **Facilitator/Critic** einer Agentenbesprechung.',\n  'Aufgaben:',\n  '- Verdichte die bisherigen Team-Ergebnisse,',\n  '- markiere Widersprüche/Lücken,',\n  '- formuliere max. 3 konkrete Fokusaufgaben für die nächste Runde,',\n  '- entscheide, ob eine weitere Runde nötig ist (stop=true/false).'\n].join('\\n');\n\nconst boardText = j.boardText || '';\nconst criticUser = [\n  `Aufgabe (User): ${basePrompt}`,\n  '',\n  `Runde ${round} von ${total}`,\n  '',\n  'Bisherige Team-Ergebnisse:',\n  boardText || '(noch keine)',\n  '',\n  'Erwarte JSON: { \"summary\": string, \"focus\": [string], \"stop\": boolean }'\n].join('\\n');\n\nreturn {\n  json: {\n    ...j,\n    ...mapped,\n    // WICHTIG: State-Felder explizit mitgeben\n    round,\n    agent_rounds: total,\n    // Anzeige/Memory: _original_prompt setzen, prompt für den Critic setzen\n    _original_prompt: basePrompt,\n    prompt: criticUser,\n    system: criticSystem\n  }\n};\n"
      },
      "id": "d9f684a0-7546-42e2-b2f7-0456871d0c05",
      "name": "Prepare Critic Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2960,
        -624
      ]
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "2cmATLhSNBMN3a2H",
          "mode": "list",
          "cachedResultName": "RAG_router_v3"
        },
        "workflowInputs": {
          "mappingMode": "passThrough",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "id": "271ea56b-3a1a-45a0-830c-7b6ecba858a0",
      "name": "Run RAG_Router (Critic)",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        3632,
        -624
      ]
    },
    {
      "parameters": {
        "jsCode": "// Apply Critic Feedback — CONSOLIDATE to a single state item\nconst inputs = $input.all();\nconst state  = ($items('Prepare Critic Prompt', 0)?.[0]?.json) || {};\n\nfunction firstValidJson(arr) {\n  for (const it of arr) {\n    const raw = it.json?.result || it.json?.text || '';\n    if (!raw) continue;\n    try { return JSON.parse(raw); } catch {}\n    const m = String(raw).match(/\\{[\\s\\S]*\\}/);\n    if (m) { try { return JSON.parse(m[0]); } catch {} }\n  }\n  return null;\n}\n\nconst parsed = firstValidJson(inputs) || {};\nconst summary = String(parsed.summary || '').trim();\nconst focus   = Array.isArray(parsed.focus) ? parsed.focus : [];\nconst stop    = Boolean(parsed.stop);\n\nconst addBlock = [\n  summary ? `## Facilitator-Summary\\n${summary}` : '',\n  focus.length ? `## Fokus für nächste Runde\\n- ${focus.join('\\n- ')}` : ''\n].filter(Boolean).join('\\n\\n');\n\nconst newBoardText = [state.boardText || '', addBlock].filter(Boolean).join('\\n\\n');\n\nreturn [{\n  json: { ...state, boardText: newBoardText, critic_summary: summary || undefined, critic_focus: focus, stop }\n}];\n"
      },
      "id": "2fa88c52-73ad-410d-82fe-80772e7aae38",
      "name": "Apply Critic Feedback",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3856,
        -624
      ]
    },
    {
      "parameters": {
        "jsCode": "// STATE MANAGER NODE – Zentraler Rundenzähler & Event-Basis (ohne Cross-Refs)\n// - Arbeitet ausschließlich mit $input.all()\n// - Keine $items(...) / $node[...] → keine versteckten Abhängigkeiten\n// - Liefert __event_base, damit Event-Nodes nur $json brauchen\n\nconst allItems = $input.all();\n\nfunction normStr(v) {\n  return (typeof v === 'string' ? v : (v == null ? '' : String(v)))\n    .replace(/^=+/, '') // z.B. \"=Barrista\" -> \"Barrista\"\n    .trim();\n}\nfunction pick(...vals) {\n  for (const v of vals) {\n    if (v === undefined || v === null) continue;\n    if (typeof v === 'string' && v.trim() === '') continue;\n    return v;\n  }\n  return undefined;\n}\nfunction pickFromItems(keys) {\n  for (const it of allItems) {\n    const j = it?.json || {};\n    for (const k of keys) {\n      const v = j[k];\n      if (v === undefined || v === null) continue;\n      if (typeof v === 'string' && v.trim() === '') continue;\n      return v;\n    }\n  }\n  return undefined;\n}\nfunction parseJobIdFromUrl(u) {\n  if (typeof u !== 'string') return undefined;\n  const m = u.match(/\\/rag\\/jobs\\/([0-9a-fA-F-]+)/);\n  return m?.[1];\n}\n\nconsole.log('=== STATE MANAGER ===');\nconsole.log(`Received ${allItems.length} items`);\n\nlet currentState = null;\nlet highestRound = 0;\nlet hasBoard = false;\n\n// besten State wählen\nfor (const it of allItems) {\n  const data = it.json || {};\n  const round = Number(data.round || 1);\n  const itemHasBoard = Array.isArray(data.board) && data.board.length > 0;\n  const itemHasCriticFeedback = Object.prototype.hasOwnProperty.call(data, 'stop');\n\n  if (\n    round > highestRound ||\n    (round === highestRound && itemHasBoard && !hasBoard) ||\n    (round === highestRound && itemHasCriticFeedback)\n  ) {\n    highestRound = round;\n    currentState = data;\n    hasBoard = itemHasBoard;\n  }\n}\n\nif (!currentState) {\n  currentState = { round: 1, agent_rounds: 2, board: [], boardText: '', stop: false };\n}\n\n// IDs & Basiswerte aus Items zusammensuchen (ohne Node-Refs)\nconst jobId = pick(\n  currentState.job_id,\n  pickFromItems(['job_id','jobId','id']),\n  parseJobIdFromUrl(pickFromItems(['events','result','complete']))\n) || null;\n\nconst convId = pick(currentState.conversation_id, pickFromItems(['conversation_id','conversationId'])) || null;\n\nconst persona = normStr(pick(currentState.persona, currentState.label, pickFromItems(['persona','label']), ''));\nconst role    = normStr(pick(currentState.role, pickFromItems(['role']), ''));\nconst round   = Number(pick(currentState.round, pickFromItems(['round'])) ?? 1);\nconst rounds  = Number(pick(currentState.agent_rounds, pickFromItems(['agent_rounds','rounds_total','roundsTotal'])) ?? 1);\n\nconst board   = Array.isArray(currentState.board) ? currentState.board : [];\nconst boardText = normStr(pick(currentState.boardText, currentState.answer, pickFromItems(['boardText','answer']), ''));\n\n// Standard-URLs (relativ, Nginx routet)\nconst eventsUrl   = pick(currentState.events,   jobId ? `/rag/jobs/${jobId}/events`   : '');\nconst resultUrl   = pick(currentState.result,   jobId ? `/rag/jobs/${jobId}/result`   : '');\nconst completeUrl = pick(currentState.complete, jobId ? `/rag/jobs/${jobId}/complete` : '');\n\nconst finalState = {\n  ...currentState,\n\n  // Kanonische Felder\n  round,\n  agent_rounds: rounds,\n  board,\n  boardText,\n  stop: Boolean(currentState.stop),\n\n  // IDs\n  job_id: jobId,\n  conversation_id: convId,\n\n  // Persona/Rolle\n  persona,\n  role,\n\n  // Endpunkte\n  events:   eventsUrl,\n  result:   resultUrl,\n  complete: completeUrl,\n\n  // Event-Basis (für Evt-Nodes/emit_event)\n  __event_base: {\n    job_id: jobId,\n    persona,\n    role,\n    round,\n    rounds_total: rounds\n  },\n\n  _state_manager: {\n    picked_from_items: allItems.length,\n    has_board: hasBoard,\n    ts: new Date().toISOString()\n  }\n};\n\n// EXAKT EIN ITEM zurück\nreturn [{ json: finalState }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4304,
        -624
      ],
      "id": "41427986-dd1c-4863-a182-2a758a97d77c",
      "name": "State Manager"
    },
    {
      "parameters": {
        "jsCode": "const j = $json || {};\n\nconst round = Number(j.round || 1);\nconst maxRounds = Number(j.agent_rounds || 1);\nconst criticStop = Boolean(j.stop);\n\n// Einfache Abbruchlogik\nconst shouldContinue = !criticStop && round <= maxRounds;\n\n// Stop-Gründe sammeln\nconst stopReasons = [];\nif (criticStop) stopReasons.push(\"Critic Stop\");\nif (round > maxRounds) stopReasons.push(`Max Rounds (${round}>${maxRounds})`);\n\nconsole.log(`=== LOOP CHECKER ===`);\nconsole.log(`Round: ${round}/${maxRounds}`);\nconsole.log(`Critic Stop: ${criticStop}`);\nconsole.log(`Should Continue: ${shouldContinue}`);\nif (stopReasons.length > 0) {\n  console.log(`Stop Reasons: ${stopReasons.join(', ')}`);\n}\n\nreturn [{\n  json: {\n    ...j,\n    shouldContinue,\n    _loop_info: {\n      round,\n      maxRounds,\n      criticStop,\n      stopReasons: stopReasons.length > 0 ? stopReasons : null,\n      decision: shouldContinue ? 'CONTINUE' : 'STOP',\n      timestamp: new Date().toISOString()\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4528,
        -624
      ],
      "id": "f04a318b-0948-43be-afe6-f32738cd7a4e",
      "name": "Loop Checker"
    },
    {
      "parameters": {
        "jsCode": "// Round Incrementer — collapse to single state & bump round\nconst items = $input.all();\nconst base  = (items[items.length - 1]?.json) || ($json || {});\nconst currentMax = Math.max(...items.map(it => Number(it.json?.round ?? 1)), Number(base.round ?? 1));\nconst total = Number(base.agent_rounds ?? items[0]?.json?.agent_rounds ?? 1);\n\nreturn [{ json: { ...base, round: currentMax + 1, agent_rounds: total } }];\n"
      },
      "id": "3819c219-8ef5-46ee-b0e8-51386deff4f1",
      "name": "Round Incrementer",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4080,
        -624
      ]
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        64,
        -544
      ],
      "id": "7bfbc1fb-fe1e-4090-a3a3-7b8213c3f7df",
      "name": "Merge"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "761fd3b9-13a5-4825-b268-020062e0eac2",
              "leftValue": "={{ $json.shouldContinue === true }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        4752,
        -624
      ],
      "id": "7fb6a304-f7d7-496b-bbef-f18629f3d4f9",
      "name": "Loop Gate"
    },
    {
      "parameters": {
        "jsCode": "// Parse Tool Calls from LLM text — robust, mehrere JSON-Objekte erlaubt\n// Erwartet in den Agenten-Antworten eingebettete Blöcke wie:\n// {\"tool\":\"web.search\",\"input\":{\"query\":\"...\", \"top_k\":3, \"recency_days\":30}}\n// {\"tool\":\"db.query\",\"input\":{\"kind\":\"postgres\",\"conn\":\"cred:pg_ro\",\"sql\":\"SELECT ... LIMIT 25\"}}\n\nconst MAX_CALLS = 3;\n\nfunction extractJsonObjects(s) {\n  const out = [];\n  const text = String(s || \"\");\n  // Simple JSON object finder (tolerant)\n  const regex = /\\{[\\s\\S]*?\\}/g;\n  let m;\n  while ((m = regex.exec(text)) !== null) {\n    try { out.push(JSON.parse(m[0])); } catch {}\n  }\n  return out;\n}\n\nconst items = $input.all();\nconst calls = [];\n\nfor (const it of items) {\n  const j = it.json || {};\n  const raw = j.text || j.result || j.response || \"\";\n  const found = extractJsonObjects(raw).filter(o => o && o.tool && o.input);\n  for (const f of found) calls.push(f);\n}\n\n// Limit & normalize\nconst allowed = calls.slice(0, MAX_CALLS).map((c, i) => ({\n  tool: String(c.tool).toLowerCase().trim(),\n  input: c.input || {},\n  _tool_idx: i + 1\n}));\n\nreturn [{\n  json: {\n    ...($json || {}),\n    tools: allowed,\n    _tools_info: { requested: calls.length, allowed: allowed.length, max: MAX_CALLS }\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2064,
        -624
      ],
      "id": "a025293a-5821-4bcf-b267-6f55cbe0e697",
      "name": "Parse Tool Calls"
    },
    {
      "parameters": {
        "jsCode": "// Merge Tool Observations into State & BoardText\n\n// Aktueller State kommt bei dir aus vorherigen Nodes (z. B. Collect Agent Outputs / State Manager)\nconst state = ($items('Collect Agent Outputs', 0)?.[0]?.json) \n           || ($items('State Manager', 0)?.[0]?.json) \n           || ($json || {});\n\nconst toolsIn = ($json && Array.isArray($json.tool_observations)) ? $json.tool_observations : [];\n\nfunction fmtObs(o, idx) {\n  if (o.tool === 'web.search' && Array.isArray(o.items)) {\n    const lines = o.items.slice(0, 5).map((it,i)=>`- ${it.title || '(ohne Titel)'} — ${it.url || ''}\\n  ${it.snippet ? String(it.snippet).slice(0,240) : ''}`);\n    return `## Tool #${idx+1}: Websuche\\n${lines.join('\\n')}`;\n  }\n  if (o.tool === 'db.query') {\n    const rc = Number(o.rowCount || (o.rows?.length || 0));\n    const sample = Array.isArray(o.rows) ? o.rows.slice(0, 1)[0] : null;\n    return `## Tool #${idx+1}: DB-Query (${rc} Zeilen)\\n` + (sample ? \"Beispiel:\\n\" + JSON.stringify(sample, null, 2) : \"\");\n  }\n  if (o.tool === 'program.run') {\n    const out = String(o.stdout || '').slice(0, 1500);\n    const note = o.truncated ? '\\n[... gekürzt ...]' : '';\n    return `## Tool #${idx+1}: Programm-Ausgabe (Exit ${o.exitCode})\\n${out}${note}`;\n  }\n  return `## Tool #${idx+1}: ${o.tool}\\n${JSON.stringify(o).slice(0, 1000)}`;\n}\n\nconst toolsBlock = toolsIn.length ? `\\n\\n# Werkzeuge\\n${toolsIn.map(fmtObs).join('\\n\\n')}` : \"\";\n\nconst merged = {\n  ...state,\n  tool_observations: toolsIn,\n  boardText: [state.boardText || '', toolsBlock].filter(Boolean).join('\\n\\n')\n};\n\nreturn [{ json: merged }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2736,
        -688
      ],
      "id": "f5925164-aa96-4a56-ab6d-ffe15feb34c0",
      "name": "Merge Tool Observations"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "7TJSkMtcQ9WBo4YM",
          "mode": "list",
          "cachedResultName": "tools_router_v1"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        2512,
        -688
      ],
      "id": "785f05ea-2008-49bf-aeff-7b378c3d048e",
      "name": "Run Tools Router"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "d5fa0809-dcbe-476c-85d1-b2c512453860",
              "leftValue": "={{ Array.isArray($json.tools) && $json.tools.length > 0 }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2288,
        -624
      ],
      "id": "bedbe805-182e-4a43-874f-fbe40ffb47d0",
      "name": "If"
    },
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -384,
        -480
      ],
      "id": "0ae73f5c-5fca-42b5-9aa6-a6ec974ebfa4",
      "name": "Execute Subflow"
    },
    {
      "parameters": {
        "jsCode": "const init = $items('Init Round State', 0)?.[0]?.json ?? {};\nconst s = $json ?? {};\n\nreturn [{\n  json: {\n    ok: true,\n    __final: true,\n    job_id: init.job_id ?? s.job_id ?? null,\n    conversation_id: init.conversation_id ?? s.conversation_id ?? null,\n    answer: s.answer ?? s.boardText ?? '',\n    sources: s.sources ?? s.documents ?? [],\n    artifacts: s.artifacts ?? {},\n    personas: s.personas ?? init.personas ?? [],\n    agent_rounds: s.agent_rounds ?? init.agent_rounds ?? 1\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        6096,
        -496
      ],
      "id": "146349ae-bfda-4e01-a568-2ca23a21a567",
      "name": "Finalize State"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "gTyBULqGMjgEgoHd",
          "mode": "list",
          "cachedResultName": "emit_event"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "mode": "each",
        "options": {
          "waitForSubWorkflow": false
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        5200,
        -688
      ],
      "id": "ad6f7ceb-e444-4cca-bdbf-c991338ff261",
      "name": "Run emit_event",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const s = item.json;\nconst base = s.__event_base ?? {\n  job_id: s.job_id ?? null,\n  persona: s.persona ?? s.label ?? '',\n  role: s.role ?? '',\n  round: Number(s.round ?? 1),\n  rounds_total: Number(s.agent_rounds ?? 1),\n};\nitem.json.__event = {\n  ...base,\n  stage: 'round_start',\n  message: `Starte Runde ${base.round}/${base.rounds_total}`,\n};\nreturn item;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4976,
        -688
      ],
      "id": "a63e523f-5686-4047-8998-ae76706b6af0",
      "name": "Build Event: Round Start"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const s = item.json;\nconst base = s.__event_base ?? {\n  job_id: s.job_id ?? null,\n  persona: s.persona ?? s.label ?? '',\n  role: s.role ?? '',\n  round: Number(s.round ?? 1),\n  rounds_total: Number(s.agent_rounds ?? 1),\n};\nitem.json.__event = {\n  ...base,\n  stage: 'writer',\n  message: 'Schreiberling fasst Team-Ergebnisse zusammen',\n};\nreturn item;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5200,
        -496
      ],
      "id": "e0c9b077-de4b-4947-8b22-3d773b1f0a3b",
      "name": "Build Event: Writer"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "gTyBULqGMjgEgoHd",
          "mode": "list",
          "cachedResultName": "emit_event"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "mode": "each",
        "options": {
          "waitForSubWorkflow": false
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        5424,
        -496
      ],
      "id": "18975f28-ed63-4062-929b-7dfa3c0a25f2",
      "name": "Run emit_event1",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const s = item.json;\nconst base = s.__event_base ?? {\n  job_id: s.job_id ?? null,\n  persona: s.persona ?? s.label ?? '',\n  role: s.role ?? '',\n  round: Number(s.round ?? 1),\n  rounds_total: Number(s.agent_rounds ?? 1),\n};\nitem.json.__event = {\n  ...base,\n  stage: 'critic',\n  message: 'allsehendes Auge wirft einen Blick...',\n};\nreturn item;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3184,
        -624
      ],
      "id": "f99cafff-ddd3-4c79-ac2b-2e3f3fbf1be0",
      "name": "Build Event: Critic"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "gTyBULqGMjgEgoHd",
          "mode": "list",
          "cachedResultName": "emit_event"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "mode": "each",
        "options": {
          "waitForSubWorkflow": false
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        3408,
        -624
      ],
      "id": "d14a826c-4538-46f2-b416-6230be243aab",
      "name": "Run emit_event2",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Build Event: Persona Done (Function Item)\nconst s = item.json ?? {};\nconst label = (s.persona ?? s.label ?? 'Persona').toString().replace(/^=+/, '').trim();\n\nitem.json.__event = {\n  job_id: s.job_id ?? null,\n  persona: label,\n  role: s.role ?? '',\n  round: Number(s.round ?? 1),\n  rounds_total: Number(s.agent_rounds ?? 1),\n  stage: 'persona_start',\n  message: `${label} arbeitet an Beitrag...`,\n};\nreturn item;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        512,
        -624
      ],
      "id": "c991d9b4-261e-4361-b6dd-f28c7cca5f9c",
      "name": "Build Event: Persona Start"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "gTyBULqGMjgEgoHd",
          "mode": "list",
          "cachedResultName": "emit_event"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "mode": "each",
        "options": {
          "waitForSubWorkflow": false
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        736,
        -624
      ],
      "id": "9c61cce9-d4ea-4f74-a51d-9b059b287600",
      "name": "Run emit_event3",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Build Event: Persona Done (Function Item)\nconst s = item.json ?? {};\nconst label = (s.persona ?? s.label ?? 'Persona').toString().replace(/^=+/, '').trim();\n\nitem.json.__event = {\n  job_id: s.job_id ?? null,\n  persona: label,\n  role: s.role ?? '',\n  round: Number(s.round ?? 1),\n  rounds_total: Number(s.agent_rounds ?? 1),\n  stage: 'persona_done',\n  message: `fertig – ${label}`,\n};\nreturn item;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1392,
        -624
      ],
      "id": "8075d855-79dc-4462-aeba-172582735b4d",
      "name": "Build Event: Persona Done"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "gTyBULqGMjgEgoHd",
          "mode": "list",
          "cachedResultName": "emit_event"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "mode": "each",
        "options": {
          "waitForSubWorkflow": false
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        1616,
        -624
      ],
      "id": "eed89c6b-1bab-4ea0-8b01-b2f3eeed6d1d",
      "name": "Run emit_event4",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Final Return  (Function, Run once for all items)\nconst ins = $input.all();\n\n// Prefer the item tagged by Finalize State\nlet fin = ins.find(it => it?.json?.__final === true);\n\n// Fallbacks (falls Tag fehlt)\nif (!fin) fin = ins.find(it => it?.json && (it.json.answer !== undefined && it.json.answer !== ''));\nif (!fin) fin = ins[0];  // allerletzter Notfall\n\nreturn [{ json: fin.json }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        6320,
        -496
      ],
      "id": "dfe90553-a519-4a80-9a7f-f8f255b5fd44",
      "name": "Final Return"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1168,
        -640
      ],
      "id": "8cae806d-41bb-46aa-acea-989a4b57263f",
      "name": "Collect Data"
    }
  ],
  "pinData": {},
  "connections": {
    "Prepare Persona Items": {
      "main": [
        [
          {
            "node": "Build Event: Persona Start",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run RAG_Router (Agents)": {
      "main": [
        [
          {
            "node": "Collect Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collect Agent Outputs": {
      "main": [
        [
          {
            "node": "Parse Tool Calls",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run RAG_Router (Writer)": {
      "main": [
        [
          {
            "node": "Format Agent Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Agents Preflight (Normalize)": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Build Writer Prompt": {
      "main": [
        [
          {
            "node": "Build Event: Writer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Critic Prompt": {
      "main": [
        [
          {
            "node": "Build Event: Critic",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run RAG_Router (Critic)": {
      "main": [
        [
          {
            "node": "Apply Critic Feedback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apply Critic Feedback": {
      "main": [
        [
          {
            "node": "Round Incrementer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Init Round State": {
      "main": [
        [
          {
            "node": "State Manager",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "State Manager": {
      "main": [
        [
          {
            "node": "Loop Checker",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Checker": {
      "main": [
        [
          {
            "node": "Loop Gate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Round Incrementer": {
      "main": [
        [
          {
            "node": "State Manager",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Prepare Persona Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Gate": {
      "main": [
        [
          {
            "node": "Build Event: Round Start",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Writer Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Tool Calls": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Tool Observations": {
      "main": [
        [
          {
            "node": "Prepare Critic Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run Tools Router": {
      "main": [
        [
          {
            "node": "Merge Tool Observations",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Run Tools Router",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Critic Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Subflow": {
      "main": [
        [
          {
            "node": "Agents Preflight (Normalize)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Init Round State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Agent Response": {
      "main": [
        [
          {
            "node": "Finalize State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Finalize State": {
      "main": [
        [
          {
            "node": "Final Return",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Event: Round Start": {
      "main": [
        [
          {
            "node": "Run emit_event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Event: Writer": {
      "main": [
        [
          {
            "node": "Run emit_event1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Event: Critic": {
      "main": [
        [
          {
            "node": "Run emit_event2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Event: Persona Start": {
      "main": [
        [
          {
            "node": "Run emit_event3",
            "type": "main",
            "index": 0
          },
          {
            "node": "Collect Data",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Build Event: Persona Done": {
      "main": [
        [
          {
            "node": "Run emit_event4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run emit_event3": {
      "main": [
        [
          {
            "node": "Run RAG_Router (Agents)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run emit_event4": {
      "main": [
        [
          {
            "node": "Collect Agent Outputs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run emit_event2": {
      "main": [
        [
          {
            "node": "Run RAG_Router (Critic)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run emit_event1": {
      "main": [
        [
          {
            "node": "Run RAG_Router (Writer)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run emit_event": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collect Data": {
      "main": [
        [
          {
            "node": "Build Event: Persona Done",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "8f808d0c-0cc2-4f5b-b0a3-43461bb7e15e",
  "meta": {
    "instanceId": "5e9f1d1029083353f9423560cb0b3070390ad03855815e064cf1d2e50cd094b4"
  },
  "id": "sbK9V2KSnyb2GGxG",
  "tags": [
    {
      "createdAt": "2025-08-15T08:00:40.082Z",
      "updatedAt": "2025-08-15T08:00:40.082Z",
      "id": "MIGc52SFD5ylOxsf",
      "name": "Subflow"
    }
  ]
}