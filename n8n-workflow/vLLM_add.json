{
  "name": "Meeting: Transcribe + Summarize (Webhook)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "meetings/upload",
        "responseMode": "responseNode",
        "options": {
          "binaryData": true
        }
      },
      "id": "WebhookStart",
      "name": "Webhook Start",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        -800,
        300
      ],
      "webhookId": "meeting-upload"
    },
    {
      "parameters": {
        "functionCode": "const bin = $binary.file || $binary.data || $binary.audio;\nif (!bin) {\n  throw new Error('Kein Binary-Upload gefunden. Erwarte multipart Feldname \"file\".');\n}\n\n// Dateiname + simple Metadaten ableiten\nconst fn = (bin.fileName || $json.filename || 'meeting.m4a');\nconst mIso = fn.match(/\\d{4}-\\d{2}-\\d{2}/);\nconst mDe  = fn.match(/\\b(\\d{1,2})\\.(\\d{1,2})\\.(\\d{4})\\b/);\nlet meeting_date = mIso ? mIso[0] : (mDe ? `${mDe[3]}-${String(mDe[2]).padStart(2,'0')}-${String(mDe[1]).padStart(2,'0')}` : new Date().toISOString().slice(0,10));\nconst title = $json.title || `Vertriebssitzung ${meeting_date}`;\nconst meeting_id = ($json.meeting_id || `${meeting_date}-vertrieb`).toLowerCase();\nconst speaker_hints = ($json.speaker_hints || 'Jan (IT), Michael (GF)');\n\nreturn [{\n  meeting_date,\n  meeting_id,\n  title,\n  speaker_hints,\n  filename: fn\n}];"
      },
      "id": "PrepMeta",
      "name": "Prepare Metadata",
      "type": "n8n-nodes-base.function",
      "typeVersion": 2,
      "position": [
        -560,
        300
      ]
    },
    {
      "parameters": {
        "url": "https://ai.intern/rag/transcribe",
        "responseFormat": "json",
        "options": {
          "timeout": 1800000,
          "allowUnauthorizedCerts": true,
          "redirect": {
            "redirect": true
          },
          "bodyContentType": "multipart-form-data"
        },
        "sendBinaryData": true,
        "binaryPropertyName": "file",
        "headerParametersUi": {
          "parameter": [
            {
              "name": "x-api-key",
              "value": "change-me"
            }
          ]
        },
        "jsonParameters": false,
        "bodyParametersUi": {
          "parameter": [
            {
              "name": "diarize_flag",
              "value": "true"
            },
            {
              "name": "identify",
              "value": "true"
            },
            {
              "name": "speaker_hints",
              "value": "={{$json.speaker_hints}}"
            }
          ]
        }
      },
      "id": "Transcribe",
      "name": "Transcribe (/rag/transcribe)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -320,
        300
      ]
    },
    {
      "parameters": {
        "functionCode": "// Normalisiere Segmente & Fallback-Name\nconst res = $json;\nconst fallback = res?.identify?.name || null;\nconst segs = (res.segments || []).map(s => ({\n  start_ms: Number(s.start_ms || 0),\n  end_ms: Number(s.end_ms || 0),\n  text: String(s.text || '').trim(),\n  name: s.name || s.speaker || fallback || null\n})).filter(s => s.text);\n\n// Sprecherliste für Meta\nconst speakers = Array.from(new Set(segs.map(s => s.name).filter(Boolean)));\n\nreturn [{\n  transcribe: {\n    text: String(res.text || '').trim(),\n    segments: segs,\n    identify: res.identify || null,\n  },\n  speakers\n}];"
      },
      "id": "Normalize",
      "name": "Normalize Segments",
      "type": "n8n-nodes-base.function",
      "typeVersion": 2,
      "position": [
        -80,
        300
      ]
    },
    {
      "parameters": {
        "functionCode": "// Baue Prompt aus ALLEN Segmenten (ganzer Text) + strikte JSON-Vorgabe\nconst t = $json.transcribe;\nfunction mmss(ms){ const s=Math.max(0, Math.floor(ms/1000)); return `${String(Math.floor(s/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`; }\nconst lines = (t.segments||[]).map(s => `[${mmss(s.start_ms)}-${mmss(s.end_ms)}] ${(s.name||'Unbekannt')}: ${s.text}`);\nconst transcript = lines.join('\\n');\n\nconst SYSTEM = `Du bist ein präziser Meeting-Analyst. Antworte ausschließlich als gültiges JSON mit genau diesen Schlüsseln:\\n{\\n  \"tldr\": [\"<max 5 Bulletpoints>\"],\\n  \"entscheidungen\": [ { \"text\": \"...\", \"impact\": \"hoch|mittel|niedrig\" } ],\\n  \"aktionen\": [ { \"owner\": \"<Name>\", \"task\": \"...\", \"due\": \"<YYYY-MM-DD oder leer>\" } ],\\n  \"offene_fragen\": [ \"...\" ],\\n  \"risiken\": [ \"...\" ],\\n  \"zeitachse\": [ { \"from\": \"MM:SS\", \"to\": \"MM:SS\", \"topic\": \"...\" } ],\\n  \"redeanteile\": [ { \"name\": \"<Name>\", \"sekunden\": <int>, \"anteil_prozent\": <float> } ]\\n}\\nRegeln: Nutze die gelieferten Sprechernamen exakt. Keine Halluzinationen. Keine zusätzlichen Felder.`;\n\nconst PROMPT = `Transkript mit Zeitstempeln und Sprechern:\\n\\n${transcript}\\n\\nErzeuge das JSON.`;\n\nreturn [{ system: SYSTEM, prompt: PROMPT }];"
      },
      "id": "BuildPrompt",
      "name": "Build Summary Prompt",
      "type": "n8n-nodes-base.function",
      "typeVersion": 2,
      "position": [
        160,
        300
      ]
    },
    {
      "parameters": {
        "url": "http://192.168.30.43:11434/api/generate",
        "responseFormat": "json",
        "options": {
          "timeout": 600000
        },
        "jsonParameters": true,
        "headerParametersUi": {
          "parameter": []
        },
        "queryParametersUi": {
          "parameter": []
        },
        "bodyParametersJson": "={\n  \"model\": \"llama3:8b-instruct\",\n  \"system\": $json.system,\n  \"prompt\": $json.prompt,\n  \"options\": { \"temperature\": 0.2 },\n  \"stream\": false\n}"
      },
      "id": "OllamaGenerate",
      "name": "Summarize (Ollama)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        400,
        300
      ]
    },
    {
      "parameters": {
        "functionCode": "// Merge: parse Ollama-Response, liefere Gesamtobjekt für Frontend\nconst res = $json; // { response, ... }\nlet summary = null;\ntry {\n  const txt = String(res.response || '').trim().replace(/^```(?:json)?/,'').replace(/```$/,'');\n  summary = JSON.parse(txt);\n} catch (e) {\n  summary = { tldr: [], entscheidungen: [], aktionen: [], offene_fragen: [], risiken: [], zeitachse: [], redeanteile: [] };\n}\n\nconst prev = $prevNode[\"Normalize\"].json;\nconst meta = $prevNode[\"Prepare Metadata\"].json;\n\n// Redeanteile fallback aus Segmentlängen, wenn leer\nif (!summary.redeanteile || !summary.redeanteile.length) {\n  const agg = {};\n  for (const s of prev.transcribe.segments) {\n    const n = s.name || 'Unbekannt';\n    agg[n] = (agg[n]||0) + Math.max(0,(s.end_ms - s.start_ms));\n  }\n  const total = Object.values(agg).reduce((a,b)=>a+b,0) || 1;\n  summary.redeanteile = Object.entries(agg)\n    .sort((a,b)=>b[1]-a[1])\n    .map(([name,ms]) => ({ name, sekunden: Math.floor(ms/1000), anteil_prozent: Math.round((ms*100/total)*10)/10 }));\n}\n\nreturn [{\n  status: 'ok',\n  meeting: {\n    meeting_id: meta.meeting_id,\n    meeting_date: meta.meeting_date,\n    title: meta.title,\n    speakers: prev.speakers\n  },\n  transcribe: prev.transcribe,\n  summary\n}];"
      },
      "id": "MergeOutput",
      "name": "Merge Output",
      "type": "n8n-nodes-base.function",
      "typeVersion": 2,
      "position": [
        640,
        300
      ]
    },
    {
      "parameters": {
        "responseBody": "={{$json}}",
        "responseCode": 200
      },
      "id": "Respond",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        880,
        300
      ]
    }
  ],
  "connections": {
    "Webhook Start": {
      "main": [
        [
          {
            "node": "Prepare Metadata",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Metadata": {
      "main": [
        [
          {
            "node": "Transcribe (/rag/transcribe)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Transcribe (/rag/transcribe)": {
      "main": [
        [
          {
            "node": "Normalize Segments",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Segments": {
      "main": [
        [
          {
            "node": "Build Summary Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Summary Prompt": {
      "main": [
        [
          {
            "node": "Summarize (Ollama)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Summarize (Ollama)": {
      "main": [
        [
          {
            "node": "Merge Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Output": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "active": false,
  "settings": {},
  "staticData": {}
}
